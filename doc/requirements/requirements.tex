%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%=======================================================================
\documentclass{article}
%=======================================================================

\include{include}

%=======================================================================

\begin{document}

%=======================================================================
\TITLE{Software Requirements Specifications}{James Bordner}{\textbf{v0.0.1}}
%=======================================================================

%=======================================================================
\section{Introduction} \label{s:intro}
%=======================================================================

   \cello\ is a high-performance adaptive astrophysics application
   intended primarily to be run on massively hierarchical parallel
   supercomputers.  It combines leading edge software engineering
   techniques, parallel datastructures, parallelism techniques, and
   computational physics algorithms.

%=======================================================================
\section{Inputs} \label{s:inputs}
%=======================================================================

\begin{description}
\item[Problem: ] Specify problem setup
\begin{itemize}
\item  domain extents
\item  initial conditions (materials, regions, input)
\item boundary conditions (periodic, in-/out-flow, specified, dynamic)
\end{itemize}
\item[Physics: ] Specify physics components
\begin{itemize}
\item hydrodynamics
\item  cosmological expansion
\item self-gravity
\end{itemize}
\item[Algorithms: ] Specify algorithms and their parameters
\begin{itemize}
\item PPM hydro (dual-energy, etc.)
\item gravity solver (FAC, smoother, levels, etc.)
\end{itemize}
\item[Datastructures: ] Specify datastructures and their parameters
\begin{itemize}
\item PatchAMR (levels, grid size or count, rebuild method, distribution)
\item Field storage (blocked, padded, interleved)
\end{itemize}
\item[Parallelism: ] Specifiy parallelism and parameters
\begin{itemize}
\item MPI (send/recv and type, one-sided and type, what level)
\item OpenMP (num threads, what level)
\item UPC (num threads, what level)
\item pthreads (num threads, what level)
\item cooperative parallelism
\item levels for each if multiple
\end{itemize}
\item[Output: ] Output types and parameters
\begin{itemize}
\item checkpoint (dump all)
\item output (specific fields)
\item movies (type and rate)
\item analysis (type of analysis, rate)
\item level of output (files for timestep, time, etc.)
\end{itemize}
\item[Control: ] Global control
\begin{itemize}
\item fault tolerance methodology
\item adaptivity
\end{itemize}
\item[Performance: ] Performance monitoring
\end{description}




%-----------------------------------------------------------------------
\subsection{High-level Requirements}
%-----------------------------------------------------------------------

\begin{itemize}
\item Configurability
\item Adaptability
\item Flexibility
\item Performance
\item Scalability
\end{itemize}


%-----------------------------------------------------------------------
\subsubsection{Configurability}

   Configurability refers to the user-controlled component of
   mapping software and data-structures to the problem and hardware.
   It may be compile-time or run-time.

%-----------------------------------------------------------------------
\subsubsection{Adaptibility}

   Adaptivity refers to the software-controlled component of
   dynamically mapping data-structures to the problem and
   hardware.
 

   Adaptive meshes (SAMR and CAMR), to adapt data-structures to problem
   features in space.

   Adaptive time stepping, to adapt to varying timestepping
   requirements of the problem in space and time.

   Adaptive multi-algorithms, to automatically and dynamically choose
   the best of several algorithms to solve the problem.

   Adaptive data-structures, to automatically and dynamically choose
   the best of several data-structures to solve the problem.

   Adaptive parallelism, to make most efficient use of available
   hardware parallelism.



%-----------------------------------------------------------------------
\subsubsection{Flexibility}

%-----------------------------------------------------------------------
\subsubsection{Performance}

%-----------------------------------------------------------------------
\subsubsection{Scalability}

%=======================================================================
\section{Functional Requirements}
%=======================================================================

%-----------------------------------------------------------------------
\subsection{Physics}
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
\subsubsection{Hydrodynamics}

%-----------------------------------------------------------------------
\subsubsection{Self-gravity}

%-----------------------------------------------------------------------
\subsection{Data-Structures}
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
\subsubsection{Structured Adaptive Mesh Refinement}

%-----------------------------------------------------------------------
\subsubsection{Continuous Adaptive Mesh Refinement}

%-----------------------------------------------------------------------
\subsubsection{Particles}



%-----------------------------------------------------------------------
\subsection{Parallelism}
%-----------------------------------------------------------------------

MPI data parallel

MPI-2 One-sided data parallel

Functional parallelism

Task Definement and Scheduling

Multicore pipelining of physics components


Multilevel parallelism

Multiple parallelism paradigms (MPI + OpenMP)

Flexible parallelism paradigms: map parallelism to tasks

Automatic code generation (or other) of parallel tasks to implement
parallelism and optimize performance


\appendix

\section{\enzo\ parameter list}

\todo\ \code{AdjustUVBackground} \\
\todo\ \code{BaryonSelfGravityApproximation} \\
\todo\ \code{BoundaryConditionName} \\
\todo\ \code{CellFlaggingMethod} \\
\todo\ \code{ComovingCoordinates} \\
\todo\ \code{ComputePotential} \\
\todo\ \code{ConservativeInterpolation} \\
\todo\ \code{CoolDataParamfile} \\
\todo\ \code{CourantSafetyNumber} \\
\todo\ \code{CubeDumpEnabled} \\
\todo\ \code{CubeDump} \\
\todo\ \code{CycleLastDataDump} \\
\todo\ \code{CycleLastHistoryDump} \\
\todo\ \code{CycleLastRestartDump} \\
\todo\ \code{CycleSkipDataDump} \\
\todo\ \code{CycleSkipGlobalDataDump} \\
\todo\ \code{CycleSkipHistoryDump} \\
\todo\ \code{CycleSkipRestartDump} \\
\todo\ \code{DataDumpDir} \\
\todo\ \code{DataDumpName} \\
\todo\ \code{DataDumpNumber} \\
\todo\ \code{DataLabel} \\
\todo\ \code{DataUnits} \\
\todo\ \code{DomainLeftEdge} \\
\todo\ \code{DomainRightEdge} \\
\todo\ \code{dtDataDump} \\
\todo\ \code{dtHistoryDump} \\
\todo\ \code{dtMovieDump} \\
\todo\ \code{dtRestartDump} \\
\todo\ \code{dtTracerParticleDump} \\
\todo\ \code{DualEnergyFormalismEta1} \\
\todo\ \code{DualEnergyFormalismEta2} \\
\todo\ \code{DualEnergyFormalism} \\
\todo\ \code{ExternalBoundaryIO} \\
\todo\ \code{ExternalBoundaryTypeIO} \\
\todo\ \code{ExternalBoundaryValueIO} \\
\todo\ \code{ExtractFieldsOnly} \\
\todo\ \code{FluxCorrection} \\
\todo\ \code{GadgetEquilibriumCooling} \\
\todo\ \code{Gamma} \\
\todo\ \code{GlobalDir} \\
\todo\ \code{GravitationalConstant} \\
\todo\ \code{GravityBoundaryFaces} \\
\todo\ \code{GravityBoundaryName} \\
\todo\ \code{GravityBoundaryRestart} \\
\todo\ \code{GravityResolution} \\
\todo\ \code{GreensFunctionMaxNumber} \\
\todo\ \code{GreensFunctionMaxSize} \\
\todo\ \code{GridVelocity} \\
\todo\ \code{HistoryDumpDir} \\
\todo\ \code{HistoryDumpName} \\
\todo\ \code{HistoryDumpNumber} \\
\todo\ \code{huge\_number} \\
\todo\ \code{HydroMethod} \\
\todo\ \code{InitialCPUTime} \\
\todo\ \code{InitialCycleNumber} \\
\todo\ \code{Initialdt} \\
\todo\ \code{InitialTime} \\
\todo\ \code{InterpolationMethod} \\
\todo\ \code{LeftFaceBoundaryCondition} \\
\todo\ \code{LocalDir} \\
\todo\ \code{MaximumGravityRefinementLevel} \\
\todo\ \code{MaximumParticleRefinementLevel} \\
\todo\ \code{MaximumRefinementLevel} \\
\todo\ \code{MaximumSubgridSize} \\
\todo\ \code{MinimumEfficiency} \\
\todo\ \code{MinimumEnergyRatioForRefinement} \\
\todo\ \code{MinimumMassForRefinement} \\
\todo\ \code{MinimumMassForRefinementLevelExponent} \\
\todo\ \code{MinimumOverDensityForRefinement} \\
\todo\ \code{MinimumPressureJumpForRefinement} \\
\todo\ \code{MinimumPressureSupportParameter} \\
\todo\ \code{MinimumShearForRefinement} \\
\todo\ \code{MinimumSlopeForRefinement} \\
\todo\ \code{MinimumSubgridEdge} \\
\todo\ \code{MovieDataField} \\
\todo\ \code{MovieDumpDir} \\
\todo\ \code{MovieDumpName} \\
\todo\ \code{MovieDumpNumber} \\
\todo\ \code{MovieRegionLeftEdge} \\
\todo\ \code{MovieRegionRightEdge} \\
\todo\ \code{MovieSkipTimestep} \\
\todo\ \code{MultiMetals} \\
\todo\ \code{MultiSpecies} \\
\todo\ \code{MustRefineParticlesRefineToLevel} \\
\todo\ \code{NewMovieDumpNumber} \\
\todo\ \code{NewMovieLeftEdge} \\
\todo\ \code{NewMovieName} \\
\todo\ \code{NewMovieParticleOn} \\
\todo\ \code{NewMovieRightEdge} \\
\todo\ \code{NumberOfBufferZones} \\
\todo\ \code{NumberOfParticleAttributes} \\
\todo\ \code{NumberOfParticles} \\
\todo\ \code{OutputFirstTimeAtLevel} \\
\todo\ \code{ParallelParticleIO} \\
\todo\ \code{ParallelRootGridIO} \\
\todo\ \code{ParticleBoundaryType} \\
\todo\ \code{ParticleCourantSafetyNumber} \\
\todo\ \code{ParticleTypeInFile} \\
\todo\ \code{ParticleTypeInFile} \\
\todo\ \code{PartitionNestedGrids} \\
\todo\ \code{PointSourceGravityConstant} \\
\todo\ \code{PointSourceGravityCoreRadius} \\
\todo\ \code{PointSourceGravity} \\
\todo\ \code{PointSourceGravityPosition} \\
\todo\ \code{PPMDiffusionParameter} \\
\todo\ \code{PPMFlatteningParameter} \\
\todo\ \code{PPMSteepeningParameter} \\
\todo\ \code{PressureFree} \\
\todo\ \code{ProblemType} \\
\todo\ \code{RadHydroParamfile} \\
\todo\ \code{RadiationFieldLevelRecompute} \\
\todo\ \code{RadiationFieldType} \\
\todo\ \code{RadiationHydrodynamics} \\
\todo\ \code{RadiationSpectrumNormalization} \\
\todo\ \code{RadiationSpectrumSlope} \\
\todo\ \code{RadiativeCooling} \\
\todo\ \code{RandomForcingEdot} \\
\todo\ \code{RandomForcing} \\
\todo\ \code{RandomForcingMachNumber} \\
\todo\ \code{RedshiftDumpDir} \\
\todo\ \code{RedshiftDumpName} \\
\todo\ \code{RefineBy} \\
\todo\ \code{RefineByJeansLengthSafetyFactor} \\
\todo\ \code{RefineRegionLeftEdge} \\
\todo\ \code{RefineRegionRightEdge} \\
\todo\ \code{RestartDumpDir} \\
\todo\ \code{RestartDumpName} \\
\todo\ \code{RestartDumpNumber} \\
\todo\ \code{RightFaceBoundaryCondition} \\
\todo\ \code{S2ParticleSize} \\
\todo\ \code{SelfGravity} \\
\todo\ \code{SetHeIIHeatingScale} \\
\todo\ \code{SetUVBAmplitude} \\
\todo\ \code{SRBprefix} \\
\todo\ \code{StarEnergyToQuasarUV} \\
\todo\ \code{StarEnergyToStellarUV} \\
\todo\ \code{StarEnergyToThermalFeedback} \\
\todo\ \code{StarMakerMassEfficiency} \\
\todo\ \code{StarMakerMinimumDynamicalTime} \\
\todo\ \code{StarMakerMinimumMass} \\
\todo\ \code{StarMakerOverDensityThreshold} \\
\todo\ \code{StarMassEjectionFraction} \\
\todo\ \code{StarMetalYield} \\
\todo\ \code{StarParticleCreation} \\
\todo\ \code{StarParticleFeedback} \\
\todo\ \code{StaticHierarchy} \\
\todo\ \code{StaticRefineRegionLeftEdge} \\
\todo\ \code{StaticRefineRegionLevel} \\
\todo\ \code{StaticRefineRegionRightEdge} \\
\todo\ \code{StopCPUTime} \\
\todo\ \code{StopCycle} \\
\todo\ \code{StopFirstTimeAtLevel} \\
\todo\ \code{StopTime} \\
\todo\ \code{TimeActionParameter} \\
\todo\ \code{TimeActionParameter} \\
\todo\ \code{TimeActionRedshift} \\
\todo\ \code{TimeActionRedshift} \\
\todo\ \code{TimeActionTime} \\
\todo\ \code{TimeActionTime} \\
\todo\ \code{TimeActionType} \\
\todo\ \code{TimeLastDataDump} \\
\todo\ \code{TimeLastHistoryDump} \\
\todo\ \code{TimeLastMovieDump} \\
\todo\ \code{TimeLastRestartDump} \\
\todo\ \code{TimeLastTracerParticleDump} \\
\todo\ \code{tiny\_number} \\
\todo\ \code{TopGridDimensions} \\
\todo\ \code{TopGridGravityBoundary} \\
\todo\ \code{TopGridRank} \\
\todo\ \code{TracerParticleDumpDir} \\
\todo\ \code{TracerParticleDumpName} \\
\todo\ \code{TracerParticleDumpNumber} \\
\todo\ \code{TracerParticleOn} \\
\todo\ \code{UniformGravityConstant} \\
\todo\ \code{UniformGravityDirection} \\
\todo\ \code{UniformGravity} \\
\todo\ \code{Unigrid} \\
\todo\ \code{UseMinimumPressureSupport} \\
\todo\ \code{VersionNumber} \\
\todo\ \code{WritePotential} \\
\todo\ \code{ZEUSLinearArtificialViscosity} \\
\todo\ \code{ZEUSQuadraticArtificialViscosity} \\

\end{document}

%==================================================================
