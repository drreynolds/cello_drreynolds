========================================================================
Vision and Scope
========================================================================


   Overview
      Enzo: The Next Generation

   Approach

      Lessons Learned from Enzo
         Improve what needs improving
         Keep what works well
         Different people will disagree on which is which
      Areas to improve
         Science capabilities
         Hardware utilization
         Software design
         User interaction

------------------------------------------------------------------------

      User Interaction
         Easy to use
            Users should concentrate on science
            Users should not have to wrestle with software
              Unless they are experts at both
         "Wide" control: solve a large class of problems
         "Deep" control: access to "expert-level" parameters
             methods: chemistry subcycles
             physics: floors on pressure, density
         Target multiple classes of users:
            physics experts
               deep control of physics
               flexible problem set-up for new problems
            numerical experts
               deep control of methods
               easy to incorporate new methods with deep control
            students
               easy to set up simple problems and analyse results
               minimal software-related "gotcha's"
         Parameter files
            "Users should not have to write or edit code to run their problems"
            Enzo issues
               Enzo has problem-specific code (ShockTube, Cosmology, etc.)
                  inflexible
                  requires coding to add new type of problem
               Adding new parameters is error-prone and labor intensive
               Many "parameters" require editing code and recompiling
            Cello solutions
               Want to move problem specification from code into the parameter file
               Requires a more powerful input file grammar
                  scalar and logical expressions
                  control over individual fields (e.g. limits)
               But want to keep grammar simple
               New parameters can just be used
                  example of code #include "parameters.h"  
                  parameters.open_group("Initial");
                  parameters.open_name("PPM");
                  parameters.evaluate_expression("

      Hardware Utilization
         Extreme parallel scalability
         High overall performance requires high efficiency at *all* levels
            node level: load balanced memory between nodes
            cpu/core level: load balanced workload within nodes
            highly tuned kernals on cores
            take advantage of data-locality at all levels
            control over task size to optimize cache usage
            reuse data as much as possible
            basic task: 
               long sequences of operations
                  hydro + chemistry + etc.
               small blocks of data
                  e.g. 4^3 or 8^3 patches
            floating point unit usage
            maximal useful work versus data structure handling
         Adaptability of data-structures to underlying hardware
            flexibility of data-structures
               optimal grid patch sizes
            flexibility of parallelization strategies
               MPI-1 send/recv
               MPI-2 get/put
               OMP
               UPC
               GPU

      Middleware Use
         Many useful tools / approaches
           MPI HDF5
           CHARM++
      Software Design
         Object-oriented design at high levels
            Layered
              keep low-level code out of high-levels
              each function should have uniform 
            Modular: to control code inter-dependencies
            MaintProgram in problem-domain: Field, Amr, Array, Particles, Disk, Memory
            Current best approach for controlling software complexity
               modifyability
         Highly-tuned kernels at low levels
            Fortran, possible migration to C89 ("restrict")
         Modularize as much as possible
            Core physics routines independent of parallel strategies
  
      Science Capabilities
         Design and data-structures must allow pushing limits on:
            Single-resolution ("unigrid") problems
               Enzo: O(P) data-structure, single large patch per MPI process
               Cello: O(1) data-structure, multiple smaller patches for MPI-[12]/OMP/cache
            Large homogeneous multi-resolution ("AMR") problems
            Large "clustered" multi-resolution problems
            Deep problems (star formation)
            Multiple problems (parameter surveys, inter-problem analysis)

