Reduce implicit dependencies by dynamically allocating parallel tasks, ala CHARM++.(e.g. currently Enzo loops through patches within a level, but a given patch can proceed as soon as it has all its boundary data) (W004)

 Auto-tune where possible--automatically optimize for cache-, parallel-, vector-, solver-, etc. parameters (W005)

Use object-oriented design, organize into components (subdirectories) of classes (*.hpp/*.cpp files) (W006)

Method

Integrate "inits" functionality into the main code (W001)

Simulation

Support ensembles within a single run, including inline-analysis (W002)

Parallel

Support multiple (hybrid) and flexible parallelization strategies, including MPI-1 (2-sided send/recv), MPI-2 (1-sided get/put), OMP, and optionally UPC and GPU. (W003)

Control


Require more rigorous coding standards compared to Enzo development (W007)

Enforce strict control over data storage formats (e.g. files) (see W0009) (W008)

 Require that all stored data be accessed through standard interface functions that are independent of specific file formats (i.e., stored datasets are conceptually treated as objects) (W009)

 Support both structured AMR (Enzo-like) and tree-based AMR (W010)

Store particle positions in single precision as -1 <= x,y,z <= 1 relative to their containing patch. [[BR]] [To reduce storage, improve performance, and address precision issues with deep AMR.] (W011)

Do not store a patch's global position, only local position relative to immediate neighbors, parent, and children.  [[BR]][Toward distributed AMR data-structure, and to address precision issues with deep AMR.  Potential issues: boundary and initial conditions.] (see W01213) (W012)

 Represent patch extents with (small) integer values relative to parent. [[BR]][To reduce memory usage with deep AMR runs.] (see W012)  (W013)

Provide (or notify) neighboring patches with updated ghost zone data as soon as it's available. (W014)

Support optional variable timestep sizes within each level. [[BR]][To reduce synchronization costs when computing global CFL condition.] (W015)

Support optional uniform timesteps across all levels. [[BR]] [To improve parallel efficiency.] (W016)

User-controlled optional floor/ceiling limits on individual `Field`s (ala "tiny_number" in Enzo), with user-specified `Error` behavior (warning, error, ignore, reset to given floor/ceiling, etc.) (W017)

Allow multiple root-level patches per MPI task.  [[BR]][To improve cache use for unigrid problems, and improve load-balancing for AMR.] (W018)

Use a binary tree data-structure to recursively partition the bounding boxes of particles. (W019)
