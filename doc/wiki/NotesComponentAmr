([NotesComponentUser User] < [NotesComponents index] > [NotesComponentArray Array])

= `Amr` Component =

[[TOC]]

The adaptive mesh refinement component `Amr` is built on top of the [NotesComponentArray Array] distributed array component.  The `Amr` component uses `Array`s, but `Array`s do not reference `Amr`.  The `Amr` patches may be distributed, and `Array`s on each patch may themselves be distributed.
 
Tentative features of `Amr` support in Cello include the following:

 * '''Octree-like AMR'''.  We want to eliminate the need for heuristic grid placement algorithms and neighbor searches, to simplify load balancing, eliminate the need for persistent ghost zones, and to improve the scalability of representing the data-structure in a distributed memory.
 * '''Full unilevel efficiency'''.  A single-level `Amr` "hierarchy" should reduce to a single `Array`.  This is different from how `Enzo` treats "unigrid" problems, which allocates O(P) `grid` patches per MPI-process, and involves costly and unnecessary searches to find patch neighbors.
 * '''Partitioned "inter-resolution" and "intra-resolution" management'''.  The `Amr` component defines and manages the inter-refinement structure (regions where the resolution changes), whereas the `Array` component defines and manages the intra-resolution structures (regions where the resolution is uniform).
 * '''Flexibility between levels'''.  Supports refinement-by-two (octree), refinement-by-four (4^3^-tree), refinement-by-8 (8^3^-tree), etc.  Restricting to, e.g., only 4^3^ grid patches could be helpful for highly-tuned numerical methods, cache sizes, or to maintain uniform parallel task sizes.
 * '''Flexibility within levels'''.  Flexibility in array sizes, for example, 4^3^, 8^3^, etc., to match flexibility of AMR tree shapes, and allow refinement by `Array` arrays instead of by `Amr` trees.
 * '''"Smooth" refinement'''.  Intermediate "backfill levels" for refinement ratios r=4 and r=8, implemented using a "bridge" of `Array`'s between hierarchy levels, to maintain smooth r=2 resolution transitions.  This should allow efficient targeted refinement, but without introducing undue grid resolution effects.
 * '''Optimized `Amr` - `Array` data-structure partitioning'''. Efficiency can be improved by optimizing `Array`s versus the `Amr` refinement tree.  For example, if a domain is flagged to be refined everywhere, then the `Amr` data-structure detects this and collapses back to a single but larger `Array`.  An efficiency parameter is used to determine the tradeoff between more `Amr` structure versus larger `Array` overrefinement.
 * '''Scalable depth'''.  We want to allow "massively deep" `Amr` hierarchies without limits based on floating point precision or limited integer range.  For example, positions of particles associated with an `Amr` `Patch`, are stored using a coordinate system centered at the grid patch corner.  This enables more than sufficient accuracy, even with single precision.   Also, positions defining the extents of a `Patch` are also stored only relative to neighboring `Patch`es or the domain boundary.

== Issues ==

 * How to decide tradeoffs between `Array` and `Amr` refinement?
 * What support is needed for `Particles` and `Rays`?
 * How to handle remeshing?
 * How to implement distributed `Amr` meshes?
 * How to control hierarchical parallelism between `Amr` and constituent `Array`s
 * How to dynamically adjust tree size (2^3^,4^3^, 8^3^, etc.) ("adaptive adaptivity")
 * How to deal with ghost zones
 * What operations are needed to enable efficient and flexiblue load balancing

== Refinement criteria ==

Below are Enzo's documented refinement criteria ( 1 to 7 ), as well as undocumented criteria ( 8 and above )

=== 1. refine by slope ===

"Refinement by slope" flags a cell if 0.5*| (F(i+h) - F(i-h)) / F(i) |  >  `MinimumSlopeForRefinement`.  The default is all fields, except  for Implosion (just density), and Sedov blast, radiating shock, and cosmology problems (just density and total energy).

===  2. refine by baryon mass === 

Refine if (density) / (cell volume) >  MinimumMassForRefinement*r ^ (level*MinimumMassForRefinementLevelExponent))

===  3. refine by shocks ===      
===  4. refine by particle mass === 
===  5. refine by baryon overdensity (currently disabled) === 
===  6. refine by Jeans length === 
===  7. refine if cooling time < cell width/sound speed === 
=== 8. "Must refine particles" (undocumented) === 
=== 9.  shear (undocumented) === 
=== 10. "must refine region" (undocumented) === 
=== 11. metallicity (undocumented) === 
=== 12.  shockwaves (commented-out) (Skillman) (undocumented) === 
=== 20. "by hand" (undocumented) === 


== `Amr` supporting classes ==

[[Image(htdocs:uml-amr.png)]]

 * `Amr`: ''Distributed AMR hierarchy data-structure''
 * `Patch`: ''A basic rectangular (square) section of an `Amr` hierarchy with constant resolution''
 * `Tree`: ''The k^d^ tree, which may be distributed''.
 * `Node`: ''A node of the `Tree` that defines local inter-relationships with other nodes''
 * `Layout`: ''Description of how to parallelize a 3D patch.  Includes MPI, OMP, etc., and may be nested.  Part of the `Parallel` component''
 * `Box`: ''A physical box with a size and position, either absolute or relative to adjacent `Box`es''
 * `Block`: ''The smallest serialized (single thread on a single process) component of a `Patch`.  Typically corresponds to 4^3^ or similar array of `Field` data.
 * `Data`: ''The data "payload" for a given `Block`''

=== `Amr` class ===
==== `Amr` attributes ====
|| `root_[]` || Size of the root grid ||
|| `max_level_` || Maximum level for the hierarchy (0 = unigrid) ||
||  `refine_`    || ''refinement factor = 2, 4, etc.'' ||
||  `backfill_`  || ''whether to backfill for refine > 2'' ||
||  `patch_min` || ''minimum patch size'' ||
||  `patch_max` || ''maximum patch size'' ||
|| || ||
|| `tree_` || Tree defining the first k levels of the AMR hierarchy topology.  Finer levels may be distributed. ||

==== `Amr` functions ====
==== `Amr` parameters ====

||  `Amr { root }`      || ''size of the root grid, e.g. ![400,400]'' ||
||  `Amr { max_level }` || ''maximum level (with root = 0), assuming refinement by two ||
||  `Amr { refine }`    || ''refinement factor = 2, 4, etc.'' ||
||  `Amr { backfill }`  || ''whether to backfill for refine > 2'' ||
||  `Amr { patch_min }` || ''minimum patch size'' ||
||  `Amr { patch_max }` || ''maximum patch size'' ||

