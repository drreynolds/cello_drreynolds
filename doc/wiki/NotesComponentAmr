([NotesComponentTask Task] < [NotesComponents index] > [NotesComponentAnalysis Analysis])

= Amr Component =

[[TOC]]

The adaptive mesh refinement component `Amr` is built on top of the [NotesComponentArray Array] distributed array component.  The `Amr` component uses `Array`s, but `Array`s do not reference `Amr`.
 
Tentative features of `Amr` support in Cello include the following:

 * '''Octree-like AMR'''.  We want to eliminate the need for heuristic grid placement algorithms and neighbor searches, to simplify load balancing, eliminate the need for persistent ghost zones, and to improve the scalability of representing the data-structure in a distributed memory.  (Caveat: "Wish" W010 by Norman is to include structured AMR capability).
 * '''Full unilevel efficiency'''.  A single-level `Amr` "hierarchy" should reduce to a single `Array`.  This is different from `Enzo`, which allocates O(P) `grid` patches per MPI-process, and involves costly and unnecessary neighbor searches.
 * '''Partitioned "inter-resolution" and "intra-resolution" management'''.  The `Amr` component defines and manages the inter-refinement structure, whereas the `Array` component defines and manages the intra-resolution structures.
 * '''Flexibility between levels'''.  Supports refinement-by-two (octree), refinement-by-four (64-tree), refinement-by-7 (343-tree), etc.  Also perhaps "in-between" ( e.g. (2 x 4 x 4)-tree ) with corresponding rectangular arrays.  Restricting to, e.g., only 4^3^ grid patches could be helpful for highly-tuned numerical methods, cache sizes, or to maintain uniform parallel task sizes.
 * '''Flexibility within levels'''.  Flexibility in array sizes, for example, 4^3^, 7^3^, etc., to match flexibility of AMR tree shapes, and allow refinement by `Array` arrays instead of by `Amr` trees.
 * '''"Smooth" refinement'''.  Intermediate "pseudo-levels", implemented by introducing a "bridge of `Array`'s, can be introduced between existing hierarchy levels to maintain smooth resolution transitions.  This should enable using high refinement ratios (e.g. 16^3^-trees) for more efficient targeting of features, but without introducing undue grid resolution effects.
 * '''Optimized `Amr` - `Array` data-structure partitioning'''. Efficiency can be improved by optimizing `Array`s versus the `Amr` refinement tree.  For example, if a domain is flagged to be refined everywhere, then the `Amr` data-structure detects this and collapses back to a single but larger `Array`.
 * '''Scalable depth'''.  We want to allow "massively deep" `Amr` hierarchies without limits based on floating point      precision or limited integer range.  For example, positions of particles associated with an `Amr` `Patch`, are stored      with positions normalized between -1.0 and 1.0.  This enables more than sufficient accuracy, even with single precision.   Also, positions defining the extents of a `Patch` are also stored only relative to neighboring `Patch`es, or the domain boundary.

== Issues ==

 * How to decide tradeoffs between `Array` and `Amr` refinement?
 * What support is needed for `Particles`?
 * How to handle remeshing?
 * How to dynamically adjust tree size (2^3^,4^3^, 8^3^, etc.) ("adaptive adaptivity")
 * How to deal with ghost zones
 * What operations needed for load balancing

== Refinement criteria ==

Below are Enzo's documented refinement criteria ( 1 to 7 ), as well as undocumented criteria ( 8 and above )

=== 1. refine by slope ===

"Refinement by slope" flags a cell if 0.5*| (F(i+h) - F(i-h)) / F(i) |  >  `MinimumSlopeForRefinement`.  The default is all fields, except  for Implosion (just density), and Sedov blast, radiating shock, and cosmology problems (just density and total energy).

===  2. refine by baryon mass === 

Refine if (density) / (cell volume) >  MinimumMassForRefinement*r ^ (level*MinimumMassForRefinementLevelExponent))

===  3. refine by shocks ===      
===  4. refine by particle mass === 
===  5. refine by baryon overdensity (currently disabled) === 
===  6. refine by Jeans length === 
===  7. refine if cooling time < cell width/sound speed === 
=== 8. "Must refine particles" (undocumented) === 
=== 9.  shear (undocumented) === 
=== 10. "must refine region" (undocumented) === 
=== 11. metallicity (undocumented) === 
=== 12.  shockwaves (commented-out) (Skillman) (undocumented) === 
=== 20. "by hand" (undocumented) === 


== `Amr` supporting classes ==

[[Image(htdocs:uml-amr.png)]]

 * `Amr`: ''Distributed AMR hierarchy data-structure''
 * `Level`: ''Uniresolution partition of an `Amr` hierarchy''
 * `Patch`: ''A basic rectangular uniresolution section of an `Amr` hierarchy''
 * `Tree`: ''The k^d^ tree, which may be distributed''.
 * `Node`: ''A node of the `Tree` that defines local inter-relationships with other nodes''
 * `Layout`: ''Description of a Fortran-style array, which may be distributed''
 * `Box`: ''A physical box with a size and position, either absolute or relative to neighboring `Box`es''

=== `Amr` class ===
==== `Amr` attributes ====
|| `nx0_, ny0_, nz0_` || Size of the root grid ||
|| `max_level_` || Maximum level for the hierarchy (0 = unigrid) ||
|| `tree_` || Tree defining the AMR hierarchy topology ||

==== `Amr` functions ====
==== `Amr` parameters ====

||  `root`      || ''size of the root grid, e.g. ![400,400]'' ||
||  `max_level` || ''maximum level (with root = 0), assuming refinement by two ||
||  `refine`    || ''refinement factor = 2, 4, etc.'' ||
||  `full_tree` || ''whether tree is full (ala Flash) or not'' ||
||  `backfill`  || ''whether to backfill for refinement > 2'' ||
||  `coalesce`  || ''whether to coalesce small patches to one big one'' ||
||  `patch_min` || ''minimum patch size'' ||
||  `patch_max` || ''maximum patch size'' ||

