([NotesComponentParticles Particles] < [NotesComponents index] > [NotesComponentPortal Portal])

= Performance Component =

The `Performance` component is used to collect information about how efficiently the application is using the underlying hardware.  Metrics recorded include time, memory, communication, disk, floating point operations, and memory accesses.

== `Performance` class ==

`Performance` is based on the `lcaperf` package.  It collects the following data for code regions:

 || `time_real` || ''Wallclock time'' ||
 || `time_user` || ''CPU time in user code'' ||
 || `time_sys`  || ''CPU time in system'' ||
 || `time_sim`  || ''Simulation time'' ||
 || || ||
 || `comm_send_bytes` || ''Amount of data sent from this thread'' ||
 || `comm_recv_bytes` || ''Amount of data received from this thread''||
 || `comm_send_time` || ''Time spent sending data''||
 || `comm_recv_time` || ''Time spent receiving data''||
 || `comm_global_time` || ''Time spent in collective communication '' ||
 || `comm_send_count` || ''Number of sends'' ||
 || `comm_recv_count` || ''Number of receives'' ||
 || `comm_global_count` || ''Number of barriers/reductions'' ||
 || || ||
 || `mem_curr_bytes`   || ''Current number of bytes allocated'' ||
 || `mem_high_bytes`   || ''Maximum number of bytes allocated'' ||
 || `mem_new_count`    || ''Number of calls to allocate memory'' ||
 || `mem_delete_count` || ''Number of calls to deallocate memory'' ||
 || `mem_new_bytes`    || ''Number of bytes allocated'' ||
 || `mem_delete_bytes` || ''Number of bytes deallocated'' ||
 || || ||
 || `disk_read_bytes`  || ''Number of bytes read from disk'' ||
 || `disk_write_bytes` || ''Number of bytes written to disk'' ||
 || `disk_read_time`   || ''Time spent reading from disk'' ||
 || `disk_write_time`  || ''Time spent writing to disk'' ||
 || || ||
 || `user_patch_count` || ''Number of grid patches in each level'' ||
 || `user_cell_count` || ''Number of grid cells in each level'' ||
 || `user_particle_count` || ''Number of particles'' ||
 || || ||
 || `cpu_flop_count` || Number of floating point operations ||
 || `cpu_mem_count`   || Number of memory accesses ||

Performance data are partitioned into the following groups:

 || `attribute_process` || ''process rank'' [implicit] ||
 || `attribute_group`    || ''code group / component'' [memory] ||
 || `attribute_region`   || ''code region'' ||
 || `attribute_timestep` || ''Simulation timesteps'' [monotonic] ||
 || `attribute_level`    || ''AMR hierarchy level'' ||

The following metrics are computed:

 || `time_balance` || ''Relative time load balance at given level'' ||
 || `mem_balance`  || ''Relative memory load balance at given level'' ||
 || `comm_balance` || ''Relative communication load balance at given level'' ||

If a metric is unchanged for a region, then nothing is stored in memory or written to disk.  Attributes such as timestep that are monotonic allow for deallocating stored metrics after periodic dumps to disk to free memory.

One may also want to periodically clear some metrics, in particular `mem_high_bytes`, to get a more usable metric for load-balancing.  For example, `mem_high_bytes_timestep` for the largest amount of memory allocated at any one time since the previous timestep, or `mem_high_bytes_balance_<n>` for high-water memory since the last load balance step at hardware level n (0=core, 1=cpu, 2=node, etc.)

 ===  Attributes ===
 ===  Functions ===

 || `Performance::Performance()` || ''Create a new performance object'' ||
 || `Performance::~Performance()` || ''Delete a performance object'' ||
 || || ||
 || `Performance::new_attribute()`   || ''Create a new attribute'' ||
 || `Performance::get_attribute()` || ''Return the value of an attribute'' ||
 || `Performance::set_attribute()` || ''Assign a value to an attribute'' ||
 || || ||
 || `Performance::new_group()`   || ''Create a new group'' ||
 || `Performance::get_group()` || ''Return the value of an group'' ||
 || `Performance::set_group()` || ''Assign a value to an group'' ||
 || `Performance::begin_group()` || ''Define the start of a group'' ||
 || `Performance::end_group()`   || ''Define the end of a group'' ||
 || || ||
 || `Performance::new_region()`   || ''Create a new region'' ||
 || `Performance::get_region()` || ''Return the value of a region'' ||
 || `Performance::set_region()` || ''Assign a value to a region'' ||
 || `Performance::start_region()`   || ''Define the start of a region'' ||
 || `Performance::stop_region()`   || ''Define the end of a region'' ||
 || || ||
 || `Performance::new_counter()`   || ''Create a new user counter'' ||
 || `Performance::get_counter()` || ''Return the value of a counter'' ||
 || `Performance::set_counter()` || ''Assign a value to a user counter'' ||
 || `Performance::increment_counter()` || ''Increment a user counter'' ||
 || || ||
 || `Performance::flush()` || ''Flush data to disk'' ||

 ===  Usage ===
 ===  Parameters ===

([NotesComponentParticles Particles] < [NotesComponents index] > [NotesComponentPortal Portal])