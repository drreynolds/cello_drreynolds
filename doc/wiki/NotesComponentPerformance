([NotesComponentParticles Particles] < [NotesComponents index] > [NotesComponentPortal Portal])

= Performance Component =

The `Performance` component is used to collect information about how efficiently the application is using the underlying hardware.  Metrics recorded include time, memory, communication, disk, floating point operations, and memory accesses.

Performance data collected and stored is similar to `lcaperf`, but with the following modifications:

 * `( )` Regions are identified by numbers instead of strings in calls, and include a number-to-string mapping
 * `( )` All attributes and metrics are stored uniformly
 * `( )` Each region start-stop is stored, not summed, by including an (optional?) "event_number" attribute
 * `( )` Both regions and isolated points are traced
 * `( )` Only inclusive metrics are stored
 * `( )` Code is OOP, with one performance object per event (region or isolated point)
 * `( )` Data flushed to disk are deleted in memory
 * `( )` Post-processing is a single utility to improve processing speed and reduce disk access
 * `( )` Disk data is binary, possibly compressed HDF5, possibly parallel, possibly using file format standard

== `Performance` class ==

`Performance` is based on the `lcaperf` package.  It collects the following data for code regions:

 || `time_real` || ''Wallclock time'' ||
 || `time_user` || ''CPU time in user code'' ||
 || `time_sys`  || ''CPU time in system'' ||
 || `time_sim`  || ''Simulation time'' ||
 || || ||
 || `comm_bytes_recv` || ''Amount of data received by this process''||
 || `comm_bytes_reduce`|| ''Amount of data in reduction operations on this process '' ||
 || `comm_bytes_send` || ''Amount of data sent from this process'' ||
 || `comm_count_barrier` || ''Number of barrier operations'' ||
 || `comm_count_recv` || ''Number of receive operations'' ||
 || `comm_count_reduce` || ''Number of reduction operations'' ||
 || `comm_count_send` || ''Number of send operations'' ||
 || `comm_time_barrier`|| ''Time spent in barriers '' ||
 || `comm_time_recv`  || ''Time spent receiving data''||
 || `comm_time_reduce`|| ''Time spent in reduction operations'' ||
 || `comm_time_send`  || ''Time spent sending data''||
 || || ||
 || `mem_bytes_curr`   || ''Current number of bytes allocated'' ||
 || `mem_bytes_high`   || ''Maximum number of bytes allocated'' ||
 || `mem_bytes_new`    || ''Number of bytes allocated'' ||
 || `mem_bytes_delete` || ''Number of bytes deallocated'' ||
 || `mem_count_new`    || ''Number of calls to allocate memory'' ||
 || `mem_count_delete` || ''Number of calls to deallocate memory'' ||
 || || ||
 || `disk_bytes_read`  || ''Number of bytes read from disk'' ||
 || `disk_bytes_write` || ''Number of bytes written to disk'' ||
 || `disk_time_read`   || ''Time spent reading from disk'' ||
 || `disk_time_write`  || ''Time spent writing to disk'' ||
 || || ||
 || `amr_count_patch` || ''Number of grid patches in each level'' ||
 || `amr_count_cell` || ''Number of grid cells in each level'' ||
 || || ||
 || `particles_count` || ''Number of particles'' ||
 || || ||
 || `cpu_count_cycle` || Number of cycles ||
 || `cpu_count_op` || Number of operations ||
 || `cpu_count_flop` || Number of floating point operations ||
 || `cpu_count_intop` || Number of integer operations ||
 || `cpu_bytes_read`   || Number of memory reads ||
 || `cpu_bytes_write`   || Number of memory writes ||

Performance data are partitioned into the following groups:

 || `attribute_process` || ''process rank'' [implicit] ||
 || `attribute_group`    || ''code group / component'' [memory] ||
 || `attribute_region`   || ''code region'' ||
 || `attribute_timestep` || ''Simulation timesteps'' [monotonic] ||
 || `attribute_level`    || ''AMR hierarchy level'' ||

The following metrics are computed:

 || `time_balance` || ''Relative time load balance at given level'' ||
 || `mem_balance`  || ''Relative memory load balance at given level'' ||
 || `comm_balance` || ''Relative communication load balance at given level'' ||

If a metric is unchanged for a region, then nothing is stored in memory or written to disk.  Attributes such as timestep that are monotonic allow for deallocating stored metrics after periodic dumps to disk to free memory.

One may also want to periodically clear some metrics, in particular `mem_high_bytes`, to get a more usable metric for load-balancing.  For example, `mem_high_bytes_timestep` for the largest amount of memory allocated at any one time since the previous timestep, or `mem_high_bytes_balance_<n>` for high-water memory since the last load balance step at hardware level n (0=core, 1=cpu, 2=node, etc.)

 ===  Attributes ===
 ===  Functions ===

 || `Performance::Performance()` || ''Create a new performance object'' ||
 || `Performance::~Performance()` || ''Delete a performance object'' ||
 || || ||
 || `Performance::new_attribute()`   || ''Create a new attribute'' ||
 || `Performance::get_attribute()` || ''Return the value of an attribute'' ||
 || `Performance::set_attribute()` || ''Assign a value to an attribute'' ||
 || || ||
 || `Performance::new_group()`   || ''Create a new group'' ||
 || `Performance::get_group()` || ''Return the value of an group'' ||
 || `Performance::set_group()` || ''Assign a value to an group'' ||
 || `Performance::begin_group()` || ''Define the start of a group'' ||
 || `Performance::end_group()`   || ''Define the end of a group'' ||
 || || ||
 || `Performance::new_region()`   || ''Create a new region'' ||
 || `Performance::get_region()` || ''Return the value of a region'' ||
 || `Performance::set_region()` || ''Assign a value to a region'' ||
 || `Performance::start_region()`   || ''Define the start of a region'' ||
 || `Performance::stop_region()`   || ''Define the end of a region'' ||
 || || ||
 || `Performance::new_counter()`   || ''Create a new user counter'' ||
 || `Performance::get_counter()` || ''Return the value of a counter'' ||
 || `Performance::set_counter()` || ''Assign a value to a user counter'' ||
 || `Performance::increment_counter()` || ''Increment a user counter'' ||
 || || ||
 || `Performance::flush()` || ''Flush data to disk'' ||

 ===  Usage ===
 ===  Parameters ===

([NotesComponentParticles Particles] < [NotesComponents index] > [NotesComponentPortal Portal])