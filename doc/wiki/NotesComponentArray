([NotesComponentAnalysis Analysis] < [NotesComponents index] > [NotesComponentControl Control])

= `Array` Component =

[[TOC]]

The `Array` component is used to represent the concept of a Fortran-style 3D array, but with
data distributed or threaded in various ways.  Tentative functionality includes the following:

 * Related groups of 1-, 2-, 3-D style Fortran arrays
 * MPI-distributed arrays
 * OMP-threaded array
 * UPC-distributed arrays
 * Hybrid distributed/threaded arrays
 * Efficient iterators over array blocks for computations
 * Parallelization and data distribution are hidden in block iterators
 * Support for both permanent and allocate-when-needed ghost zones
 * Efficient resizing / combining / merging functions for integration with `Amr`
 * Efficient transposing / permuting of axes, e.g. for PPM to compute with stride-1 along all axes
 * Efficient ghost-zone refresh
 * Group operations for controlling relative data layout of multiple arrays
 * Support for cell-centered, face-centered, edge-centered, or corner storage
 * Optional ''blocked'' storage for improved cache use or vector behavior
 * Optional ''padding'' for low-associativity caches

To implement `Array`'s, other related classes are used to share implementation responsibilities.  These classes are described in separate pages.

 * [NotesComponentArrayLayout Layout] The `Layout` class is used to define an `Array`'s configuration, but does not allocate any data.  `Array`'s that share the same `Layout` object are said to be conforming.  An `Array`'s `Layout` describes how to distribute an `Array`'s data over MPI processes, between OpenMP threads, etc.  For unigrid problems, only one `Layout` is used.  For `Amr` problems, typically several `Layout`s are used.

 * [NotesComponentArrayBlock Block ] The `Block` class is a lightweight wrapper for portions of an `Array` to be actively computed by a single thread.  It represents a Fortran-style array, together with offset, stride, dimension, and size.

 * [NotesComponentArrayItBlock ItBlock] The `ItBlock` class is used to iterate over `Block`'s of `Array`'s that share conforming `Layout`'s.

== Issues ==

Issues with `Array`s and supporting classes include the following:

 * How to handle iterators in a way that the calling code doesn't know what `Layout` varieties are used
 * How to handle nested iterators in calling code for hybrid parallelization `Layout`s
 * How to handle load balancing
 * How to communicate between array blocks to refresh ghost zones
 * How to communicate between arrary blocks for interpolation
 * How to handle permanent versus temporary ghost zones
 * How to support cell-, face-, edge-centered variables in same layout
 * How to control layout within a `Layout`, e.g. interleave range of arrays but not others.

== Operations ==

 * Allocation and deallocation functions (`Memory`)
 * Copy functions
 * Merge / split functions (for `Amr`)
 * Universal properties functions for obtaining information about the array (dimensions, etc.)
 * `Layout`-dependent properties (MPI task distribution, cache block sizes, etc.)
 * Iterators for looping over array blocks
 * Reshape / resize functions for converting between different array configurations (blocked to unblocked, with ghosts to without ghosts, etc.)
 * Accessor functions for neighboring values
 * Refresh functions for obtaining updated ghost zone values (accesses `Parallel`)
 * I/O functions (`Disk`)

== `Array` class ==

=== Attributes ===

  || `(*)` || `Scalar * values_` || ''array elements'' ||
  || `(*)`?|| `int nx_,ny_,nz_`  || ''array size'' ||
  || `(*)` || `bool is_allocated_`  || ''true iff values_ should ever be deallocated'' ||
  || `( )` || `Layout layout_`  || ''Layout for the arrays'' ||

=== Functions ===

 || `(*)` || `Array::Array()`|| ''`Array` constructor'' ||
 || `(*)` || `Array::~Array()`|| ''`Array` destructor'' ||
 || || || ||
 || `(*)` ?|| `Array::resize()` || ''Resize an array'' ||
 || `(*)` ?|| `Array::size()` || ''Get the size of an array'' ||
 || `(*)` ?|| `Array::length()` || ''Get the length of the array'' ||
 || `(*)` ?|| `Array::values()` || ''Return a pointer to the array values'' ||
 || `(*)` ?|| `Array::operator()()` || ''Return an array element'' ||
 || || || ||
 || `( )` || `Array::allocate()`|| ''Allocate storage for the `Array`'' ||
 || `( )` || `Array::deallocate()`|| ''Allocate storage for the `Array`'' ||
 || `( )` || `Array::is_allocated()` || ''Return whether storage is allocated for the `Array`''||
 || `( )` || `Array::set_allocated()` || ''Assert whether values should or should not ever be deallocated'' ||
 || || || ||
 || `( )` || `Array::set_layout()`|| ''Set the distributed `Layout` of the `Array`'' ||
 || `( )` || `Array::get_layout()`|| ''Get the distributed `Layout` of the `Array`'' ||
 || `( )` || `Array::read_block()`|| ''Copy (alias) elements from the `Array` to the `Block` '' ||
 || `( )` || `Array::write_block()`|| ''Copy (nop) elements from the `Block` to the `Array`'' ||
 || || || ||
 || `( )` || `Array::split()` || ''Split an `Array` into two (or more) at some point along some axis'' ||
 || `( )` || `Array::merge()`  || ''Merge two (or more) `Array`s into one along some axis'' ||
 || `( )` || `Array::shrink()` || ''Shrink the `Array` by some number of zones along each axis'' ||
 || `( )` || `Array::grow()`  || ''Enlarge the `Array` by some number of zones along each axis'' ||
 || || || ||
 || `( )` || `Array::copy()`|| ''Copy arrays in the `Array` '' ||
 || `( )` || `Array::clear()`|| ''Clear/set arrays in the `Array` to the given value'' ||
 || || || ||
 || `( )` || `Array::read_disk()`|| ''Read the `Array` from disk'' ||
 || `( )` || `Array::write_disk()`|| ''Write the `Array` to disk'' ||

=== Usage ===


=== Parameters ===

