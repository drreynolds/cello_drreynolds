%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890

%=======================================================================
\documentclass{article}
%=======================================================================

\include{include}

%=======================================================================

\begin{document}

%=======================================================================
\TITLE{Improved Adaptive Mesh Refinement}{James Bordner}{$Rev$}
%=======================================================================

%=======================================================================
\section{Introduction} \label{s:intro}
%=======================================================================

AMR motivation

AMR limitation summary

AMR improvement summary

%=======================================================================
\section{AMR review} \label{s:intro}
%=======================================================================

Assumptions: structured or tree-based AMR (FV), not unstructured FE meshes
  structured / tree-based more efficient
  unstructured more flexible, e.g. conforming to internal boundaries

Define
   $r$ refinement 
   $l$ level, counting from $l=0$ root
   $L$ maximum level, with $l=0$ root
   
patch-based
  + efficient AMR (roughly optimal node counts)
  - arguably less scalable
  - variable parallel task size
  - ``deep'' refinement requires $r=4$ level jumps
  
tree-based
  + arguably more scalable
  + fixed parallel task size
  + better support for leaf-only grids 
     + reduces inter-level communication
     + does not require zeroing out grid ``shadows'' in parent
     + does not require interpolating from internal zones
    
  - inefficient AMR (excessive node counts)
  - inefficient ``deep'' refinement


%=======================================================================
\section{Patch Coalescing} \label{s:intro}
%=======================================================================

\begin{verbatim}
% 
% Issue: octree has too many nodes for refinement requirements
% Solution: coalesce uniformly refined patches into a single larger patch
% Viewpoint: use AMR machinery only when necessary; use "unigrid" when possible
%
% properties:
%
%   greatest advantage in extended regions of shallow refinement
%   note underlying refinement area remains unchanged
%   + no changes required for octree data structure
%   
%   -: parallel load balancing
%     solution 1: sub-blocking
%     solution 2: hierarchical load balancing
%     
%   +: "unigrid" degenerates into a single large patch (assuming cubical domains)
%   Compare coalescing with non-coalescing
%      storage 
%        savings versus overhead
%      patch count
%        savings
%      

\end{verbatim}

%=======================================================================
\section{Targeted Refinement} \label{s:intro}
%=======================================================================

\begin{verbatim}
%   Motivate targeted refinement
%      greatest advantage in localized regions of deep refinement
%      reduces scope of refinement on coarser levels when rebalancing
%        [note octree effect is global]
%      fewer patches
%      patch size control: helps prevent "dust patches" at fine levels
%   Describe targeted refinement
%   Describe backfill
%   Refinement criteria
%      must be such that backfill is effective
%   Compare 2, 4, 8, with and without backfill
%       take into account refinement criteria issues
%       Storage requirements
%          reduced patch count versus
%          increased storage requirement per patch
%       Computation savings
%       
%          
%       
\end{verbatim}


%=======================================================================
\section{Localization} \label{s:intro}
%=======================================================================

\begin{verbatim}
%   [consider separate paper]
%   Store tree as individual patches with immediate neighbors
%   Can replicate coarser levels globally for efficiency
%      not necessarily "top K levels"
%      can have "limited replication", e.g. within a node, of further levels
%   Can still use octree data structure
%      skip over intermediate levels
%      allows code reuse
%   Issues
%      Load balancing issues
%         locality versus distribution
%      Coarsening / Refinement
%         prevent tree patch overlap [proof]
%      
\end{verbatim}

\end{document}

%==================================================================

