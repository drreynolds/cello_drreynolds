%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890

%=======================================================================
\documentclass{article}
%=======================================================================

\include{include}

%=======================================================================

\begin{document}

%=======================================================================
\TITLE{Improved Adaptive Mesh Refinement}{James Bordner}{$Rev$}
%=======================================================================

%=======================================================================
\section{Introduction} \label{s:intro}
%=======================================================================

AMR motivation

AMR limitation summary

AMR improvement summary

%=======================================================================
\section{AMR review} \label{s:intro}
%=======================================================================

Assumptions: structured or tree-based AMR (FV), not unstructured FE meshes
  structured / tree-based more efficient
  unstructured more flexible, e.g. conforming to internal boundaries

Define
   $r$ refinement 
   $l$ level, counting from $l=0$ root
   $L$ maximum level, with $l=0$ root
   
patch-based
  + efficient AMR (roughly optimal node counts)
  - arguably less scalable
  - variable parallel task size
  - ``deep'' refinement requires $r=4$ level jumps
  
tree-based
  + arguably more scalable
  + fixed parallel task size
  + better support for leaf-only grids 
     + reduces inter-level communication
     + does not require zeroing out grid ``shadows'' in parent
     + does not require interpolating from internal zones
    
  - inefficient AMR (excessive node counts)
  - inefficient ``deep'' refinement


%=======================================================================
\section{Patch Coalescing} \label{s:intro}
%=======================================================================

% 
% Issue: octtree has too many nodes for refinement requirements
% Solution: coalesce uniformly refined patches into a single larger patch

% properties:
%
%   greatest advantage in extended regions of shallow refinement
%   underlying refinement area remains unchanged
%   + no changes required for octree data structure
%   
%   -: parallel load balancing
%     solution 1: sub-blocking
%     solution 2: hierarchical load balancing
%     
%   +: "unigrid" degenerates into a single large patch (assuming cubical domains)


%=======================================================================
\section{Targeted Refinement} \label{s:intro}
%=======================================================================

%   greatest advantage in localized regions of deep refinement

\end{document}

%==================================================================

