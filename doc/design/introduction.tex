%======================================================================@
\chapter{Introduction} \label{s:intro}
%======================================================================@

Computer languages used will be C++, C99, and source languages of
incorporated legacy code until it is rewritten.  Parallelism support
will include OpenMP, MPI-1 two-sided communication, and possibly MPI-2
one-sided communication.

   \devel{User interface: output.}
   
   \devel{User interface: portal.}
   The application will include a means for external applications to
   ``attach'' to the application (in a read-only sense) to access
   the data as it is being computed.  The purpose is to enable 
   external analysis and visualization tools to input data from the
   running application, providing the user with immediate
   feedback on the state and progress of the running simulation(s).

%  I/O

   \devel{Output.}
   Several options for how data fields and particles are read and
   stored to disk will be implemented, to improve flexibility and
   allow optimization of I/O for a given problem on a given parallel
   platform.  Parallel HDF5 will be used to optimize efficiency and
   portability.  Multiple data layouts within and between files will
   be implemented to allow optimization of I/O to a particular problem
   and file system.

%  I/O dumps, inline analysis, visualization

   Support will be available for writing the whole or part of some or
   all data fields and particles at specified times.  I/O dumps will
   include targeted support for both check-pointing (for automatic use
   by the software error recovery) and data dumps (for subsequent user
   use).  
   
%  Error recovery

   Support will be included for error prevention, identification and
   recovery.  This will include fault-tolerance methods to handle
   possible hardware faults, and self-monitoring of fields, particles,
   and other variables against physics quantity invariants
   (e.g.~positive densities, mass conservation, etc.) to identify
   potential problems as soon after they occur as possible, so that
   the user or application can halt the simulation, or restart from
   an earlier snapshot using modified parameters for physics or
   methods.

% Self-tuning

   Support will be included for tuning of various components to the
   running application and hardware platform.  Tuning will be either
   self-tuning by the running application as it monitors its
   performance, or by the user monitoring the performance of a running
   simulation.  Adaptivity will be available for physics, physics
   methods, resolution ranges, AMR data-structures and algorithms,
   field and particles data-structures, and parallelism.

Hardware platform parallelism will be considered to be multilevel,
including nodes, processors, and cores.  Computational tasks will be
flexibly organized into hierarchical levels to aid mapping to multiple
hardware parallelization levels, including grid patches, grid patch
subblocks, and multiple simulations.  Task sizes in different levels
will allow flexibility to help optimize granularity for the different
given parallelization level components.

Flexible parallelism paradigms: map parallelism to tasks

Automatic code generation (or other) of parallel tasks to implement
parallelism and optimize performance

\begin{itemize}
\item Extreme scalability
\item Extreme efficiency
\item Easy for user to compile and run
\item Easy to developer to modify and maintain
\item Powerful problem definition
\item Flexibile algorithms and parallel datastructures
\item Rigorous testing of accuracy, performance and scalability
\end{itemize}
