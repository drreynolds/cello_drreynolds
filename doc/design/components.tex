%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
\chapter{Components} \label{c:components}
%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

% \centerline{\includegraphics{uml/core-components.1}}


\centerline{\includegraphics[totalheight=3in]{components.eps}}

   This chapter describes the design of \cello\ at the component
   level.  Each component is described, including the component
   interdependencies, interface, and classes.

\begin{description}
%
 \item [Simulation (\S\ref{s:component-simulation}): ]
%
        Description and management of computational astrophysics
        problem or ensemble of problems.  Controls sequencing of and
        interactions between other components such as \code{Parallel},
        \code{Method}, and \code{Field}.
%
 \item [Problem (\S\ref{s:component-problem}): ]
%
        The problem refers to the initial setup of the problem,
        including the domain, boundary and initial conditions.
%
 \item [Region (\S\ref{s:component-region}): ]
%
        A \code{Region} is a portion of space and time.
        \code{Region}s are used whenever problem characteristics, data
        structure behavior, or physics computations vary between
        different spacial or temporal \code{Region}s.  A \code{Region}
        is used to define the entire domain.  \code{Region}s may vary
        in time, for example they may grow, shrink, appear, or
        disappear.
%
 \item [Timestep (\S\ref{s:component-timestep}): ]
%
        \code{Timestep} handles the timestepping of methods to advance
        the problem forward in time.
%
 \item [Method (\S\ref{s:component-method}): ]
%
        Defines how to simulate the physics in the computational
        universe.  A \code{Method} specifies the numerical method to
        use, which \code{Field}s are involved, and any associated
        method-specific parameters.  Sequencing and coupling of
        \code{Method}s is defined in \code{Problem} and implemented in
        \code{Control}.  Analysis and visualization are considered
        \code{Method}s as well.
%
 \item [Physics (\S\ref{s:component-physics}): ]
%
        Defines what physics to simulate in the computational
        universe.  Used to define which physics processes are enabled,
        such as self-gravity, hydrodynamics, cosmological expansion,
        etc.  Also defines any parameters associated with the physics
        of the problem being solved, such as cosmological parameters
        and the gravitational constant.
%
 \item [Field (\S\ref{s:component-field}): ]
%
        A \code{Field} is used to represent a specific continuous
        scalar or vector field.  The actual \code{Field} is
        represented either using adaptive mesh refinement via
        \code{Amr}, or as a collection of particles using
        \code{Particles}.  Includes \code{Units} to define the problem
        units, as well as scaling amount to improve numerics, and
        scaling quantization to avoid precision loss.
%
 \item [Amr (\S\ref{s:component-amr}): ]
%
        The \code{Amr} component includes classes for representing
        multi-resolution data on a hierarchy of grid patches of
        varying spacial and temporal resolutions.  The \code{AMR} data
        structures can have multiple levels of data distribution and
        parallelism.  Uses the \code{Parallel} component for
        controlling the parallel communication, synchronization, and
        load-balancing.
%
 \item [Particles (\S\ref{s:component-particles}): ]
%
        The \code{Particles} component serves to represent multi-level
        parallel distribution of sets of various types of particle
        data.  Uses the \code{Parallel} component for controlling the
        parallel communication, synchronization, distribution, and
        load-balancing of \code{Particles}.
%
 \item [Parallel (\S\ref{s:component-parallel}): ]
%
        The \code{Parallel} component is used to specify and control
        the levels of parallelizion (simulations, patches, and
        subblocks), type of parallelization (shared- or
        distributed-memory), and mechanism for controling the
        parallelism (MPI-1 2-sided, MPI-2 1-sided, OpenMP, UPC).
        Lower-level parameters provide detailed control of buffering,
        blocking or nonblocking, patch-to-processor mapping,
        subblock-to-thread mapping, etc.
%
 \item [Storage (\S\ref{s:component-storage}): ]
%
        The \code{Storage} component controls what, when, and how to
        input and output large-scale data, primarily \code{Fields}.
%
 \item [Recover (\S\ref{s:component-recover}): ]
%
        The \code{Recover} package is used to detect errors, evaluate
        them, and decide what to do about them.  This includes
        maintaining restart data dumps, and may involve shutting down
        a processor or node and rebalancing the data, etc.
%
 \item [User (\S\ref{s:component-user}): ]
%
        THe \code{User} component includes the \code{Parameters} and
        \code{Monitor} components.  The \code{Parameters} component
        reads in a parameter file or files, and provides the
        application access to parameter values.  The \code{Monitor}
        component controls what and when to output user-readable
        summary information about the running application, such as
        status summary, progress, warnings, errors, and performance
        information.
%
 \item [Portal (\S\ref{s:component-portal}): ]
%
        The \code{Portal} component controls the interaction of the
        application with external applications, for both obtaining
        information about a running simulation, and controling it.
\end{description}

%-----------------------------------------------------------------------

\input{component-simulation}
\input{component-problem}
\input{component-region}
\input{component-timestep}
\input{component-method}
\input{component-physics}
\input{component-field}
\input{component-amr}
\input{component-particles}
\input{component-parallel}
\input{component-storage}
\input{component-recover}
\input{component-user}
\input{component-portal}

% \input{component-control}
% \input{component-parameters}
% \input{      component-units}
% \input{      component-domain}
% \input{      component-boundary}
% \input{      component-initial}
% \input{      component-matter}
% \input{   component-analysis}
% \input{   component-data}
% \input{   component-performance}
