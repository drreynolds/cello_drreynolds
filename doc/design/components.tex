%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
\chapter{Components} \label{c:components}
%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

\centerline{\includegraphics{uml/core-components.1}}

Core components

\begin{itemize}
\item Control
\item Problem
\item Method
\item Data
\item Storage
\end{itemize}

\begin{itemize}
\item Parallel
\item Parallel:MPI
\item Parallel:OMP
\end{itemize}


   This chapter describes the design of \cello\ at the component
   level.  Each component is described, including the component interface and dependencies on other components.  Class-level design of each component is described in \S\ref{c:classes}.


Input is in the form of a text file that specifies
   parameter values.  The input file may optionally include other
   input files.

   Parameters are organized into functional groups, which are described
   in more detail in subsequent sections.

\begin{description}

 \item [Control (\S\ref{s:component-control}): ] Control parameters specify the
 high-level parameters, as well as controling interactions between
 other components such as Parallel, Method, and Datastructure.  May
 include sequence and interaction of physics modules, parallel dynamic
 load-balancing, refinement criteria, numerical floors and limits,
 dynamic refinement in subregions, etc.

 \item [Physics (\S\ref{s:component-physics}): ] Physics parameters are used to
 define which physics is enabled---such as self-gravity,
 hydrodynamics, cosmological expansion, etc.  They also define any
 parameters associated with the physics of the problem being solved,
 such as cosmological parameters and the gravitational constant.
 Physics parameters define what physics to simulate in the
 computational universe.

 \item [Problem (\S\ref{s:component-problem}): ] Problem parameters include
 the domain extents, boundary and initial conditions.

 \item [Units (\S\ref{s:component-units}): ] Units parameters define the problem
 units, as well as scalings for computation if different.  Allows for
 ``variable'' scaling (e.g.~to keep values near unity to avoid under-
 or overflow) and quantization of scaling factors (e.g.~scale by $2^k$
 to avoid loss of precision).

 \item [Domain (\S\ref{s:component-domain}): ] Domain parmeters include extents
 and dimensionality.

 \item [Region (\S\ref{s:component-region}): ] A region is a subset of the
 domain.  Regions are used whenever problem characteristics,
 datastructure behavior, or physics computations vary between
 different spacial regions.  A region may include the entire
 domain.

 \item [Field (\S\ref{s:component-field}): ] Field parameters define all fields
 used in the computation, including their names, and whether they are
 scalar or vector fields.  Field parameters associate the name,
 datastructure, and units.

 \item [Matter (\S\ref{s:component-matter}): ] Matter defines properties of
 different types of matter used in the simulation, such as gas
 constants, dark matter, etc.

 \item [Method (\S\ref{s:component-method}): ] Method parameters specify the
 method to use for each physics component, and any associated
 method-specific parameters.  This also includes how methods are to be
 coupled together.  Method parameters define how to simulate the
 physics in the computational universe.

 \item [Data (\S\ref{s:component-data}): ] Data parameters include listing which
 data structures to use (unigrid, SAMR, particles, subblocks, etc.),
 as well as all associated parameters (unigrid resolution, SAMR mesh
 levels, particle attributes, array subblock size control, ghost zone
 width and longevity, etc.)  Datastructure parameters define how to
 represent the continuous (infinite dimensional) problem and physics
 as a computationally solveable (finite dimensional) discrete problem.
 Some parameters, such as subblock size, may affect performance but
 not the solution.  Data parameters include Hierarchy, Particle,
 Array, and Patch parameters.

 \item [Parallel (\S\ref{s:component-parallel}): ] Parallelism parameters
 specify which levels to parallelize (simulations, patches, and
 subblocks), how to parallelize each level (MPI-1 2-sided, MPI-2
 1-sided, OpenMP, UPC), and lower-level parameters (buffering,
 blocking or nonblocking, patch-to-processor mapping,
 subblock-to-thread mapping, etc.)

 \item [Performance (\S\ref{s:component-performance}): ] Performance
 self-monitoring and optimization parameters.

 \item [Monitor (\S\ref{s:component-monitor}): ] Monitor parameters control what
 and when to output user-readable summary information about the
 running application, such as status summary, progress, warnings,
 errors, and performance information.

 \item [Storage (\S\ref{s:component-storage}): ] The \code{Storage}
 component controls what, when, and how to input and output
 large-scale data, primarily data fields.

 \item [Portal (\S\ref{s:component-portal}): ] Portal parameters control
  how to interface with external applications.

 \item [Recover (\S\ref{s:component-recover}): ] The \code{Recover}
 package controls how to detect errors, and what to do if errors are
 detected.

\end{description}

\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxxxxxxx\= \kill
\ref{s:component-control} \>      \code{Control}     \>\>\>\> \textit{Manages everything}  \\
\ref{s:component-parameters} \>\>    \code{Parameters}    \>\>\> \textit{Reading and accessing all parametrs} \\
\ref{s:component-parallel}  \>\>    \code{Parallel}      \>\>\> \textit{Manages multiple parallelization levels and technologies} \\
\ref{s:component-recover}  \>\>    \code{Recover}      \>\>\> \textit{Detects, evaluates, and recovers from hardware or software errors} \\
\ref{s:component-portal}  \>\>    \code{Portal}        \>\>\> \textit{Controls access to internal state and data by external entities} \\
\ref{s:component-performance}  \>\>    \code{Performance}   \>\>\> \textit{Measures and allows other components to access performance data} \\
\ref{s:component-monitor}  \>\>    \code{Monitor}       \>\>\> \textit{Enables users to monitor the state and progress of the simulations} \\
\ref{s:component-simulation}  \>      \code{Simulation}  \>\>\>\> \textit{Description of a single astrophysics simulation} \\
\ref{s:component-problem}  \>\>    \code{Problem}       \>\>\> \textit{Declaration of what to simulation} \\
\ref{s:component-domain}  \>\>\>  \code{Domain}          \>\> \textit{The problem domain} \\
\ref{s:component-field}  \>\>\>  \code{Field}           \>\> \textit{A scalar or vector field} \\
\ref{s:component-boundary}  \>\>\>  \code{Boundary}        \>\> \textit{Boundary conditions} \\
\ref{s:component-initial}  \>\>\>  \code{Initial}         \>\> \textit{Initial conditions} \\
\ref{s:component-region}  \>\>\>\>\code{Region}            \> \textit{A subset of the domain} \\
\ref{s:component-physics}  \>\>    \code{Physics}       \>\>\> \textit{A physical law or process and associated parameters} \\
\ref{s:component-units}  \>\>\>  \code{Units}           \>\> \textit{Units used for user and computational fields} \\
\ref{s:component-material}  \>\>\>  \code{Material}        \>\> \textit{Type of matter, e.g.~gas, H+, e-, dark matter} \\
\ref{s:component-method}  \>\>    \code{Method}        \>\>\> \textit{Numerical method for evolving a physical law or laws} \\
\ref{s:component-analysis}  \>\>    \code{Analysis}      \>\>\> \textit{Numerical method for post-processing data} \\
\ref{s:component-data}  \>\>    \code{Data}          \>\>\> \textit{Numerical representation of data fields} \\
\ref{s:component-hierarchy}  \>\>\>  \code{Hierarchy}       \>\> \textit{AMR hierarchy} \\
\ref{s:component-level}  \>\>\>  \code{Level}           \>\> \textit{Uniform resolution component of an AMR hierarchy} \\
\ref{s:component-patch}  \>\>\>  \code{Patch}           \>\> \textit{Rectangular grid of cells of uniform resolution in a hierarchy} \\
\ref{s:component-box}  \>\>\>\>\code{Box}               \> \textit{Rectangular box with position and size} \\
\ref{s:component-array}  \>\>\>\>\code{Array}             \> \textit{Array of floating-point values} \\
\ref{s:component-IO}  \>\>\code{IO}            \>\>\> \textit{Description of what data to output, how, and when}
\end{tabbing}

%-----------------------------------------------------------------------

\input{component-control}
\input{component-physics}
\input{component-units}
\input{component-problem}
\input{component-data}
\input{component-domain}
\input{component-region}
\input{component-field}
\input{component-matter}
\input{component-method}
\input{component-amr}
\input{component-particles}
\input{component-parallel}
\input{component-performance}
\input{component-monitor}
\input{component-io}
\input{component-recover}

