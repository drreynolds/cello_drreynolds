%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%=======================================================================
\documentclass{article}
%=======================================================================

\include{include}

%=======================================================================

\begin{document}

%=======================================================================
\TITLE{Software Design Description}{James Bordner}{unigrid hydro}
%=======================================================================

\tableofcontents
%=======================================================================
\section{Introduction} \label{s:intro}
%=======================================================================

Computer languages used will be C++, C99, and source languages of
incorporated legacy code.  Parallelism will be via MPI2's one-sided
\code{get()}.

%=======================================================================
\section{Compilation configuration} \label{s:compile}
%=======================================================================

%=======================================================================
\section{Command-line options} \label{s:commandline}
%=======================================================================

Usage: \code{cello} \textit{parameter-file}

%=======================================================================
\section{Input parameters} \label{s:input}
%=======================================================================

\cello\ is controlled by parameters specified in an input file.  Parameters
are organized into the following categories:

\begin{itemize}
\item Problem
\item Physics
\item Algorithms
\item Data
\item Concurrency
\item I/O
\item Performance
\end{itemize}

Equivalent \enzo\ parameters

\begin{tabular}{ll}
ControlCourantSafetyFactor        & CourantSafetyNumber \\
ControlStopCycle           & StopCycle \\
ControlStopTime            & StopTime \\
HydroMethod                & HydroMethod \\
HydroParameter "diffusion"    & PPMDiffusionParameter \\
HydroParameter "dual-energy"  & DualEnergyFormalism \\
HydroParameter "eta1"    & DualEnergyFormalismEta1 \\
HydroParameter "eta2"    & DualEnergyFormalismEta2 \\
HydroParameter "flattening"   & PPMFlatteningParameter \\
HydroParameter "pressure free" & PressureFree \\
HydroParameter "steepening"  & PPMSteepeningParameter \\
Material1Gamma             & Gamma \\
OutputUserDt               & dtDataDump \\
OutputUserDumpName         & DataDumpName \\
ProblemBcLower             & LeftFaceBoundaryCondition \\
ProblemBcUpper             & RightFaceBoundaryCondition \\
ProblemDomainLower         & DomainLeftEdge \\
ProblemDomainUpper         & DomainRightEdge \\
ProblemStartCycle          & InitialCycleNumber \\
ProblemStartTime           & InitialTime \\
                           & ProblemType \\
\end{tabular}

%-----------------------------------------------------------------------
\subsection{Problem parameters}
%-----------------------------------------------------------------------

Problem parameters specify the setup of the physical problem,
including initial conditions of relevant data fields and boundary
conditions.

  dimensionality
  domain extents
  initial conditions (materials, regions, input)
 boundary conditions (periodic, in-/out-flow, specified, dynamic)

%-----------------------------------------------------------------------
\subsection{Physics parameters}
%-----------------------------------------------------------------------

Physics parameters specify physics modules and units.

 hydrodynamics
  cosmological expansion
 self-gravity

Hydrodynamics


%-----------------------------------------------------------------------
\subsection{Algorithms parameters} 
%-----------------------------------------------------------------------

Specify algorithms and their parameters.

Hydrodynamics dual-energy

Hydrodynamics steepening
Hydrodynamics flattening
Hydrodynamics diffusion

Timestepping

%-----------------------------------------------------------------------
\subsection{Data parameters}
%-----------------------------------------------------------------------

Specify low-level datastructures (fields and particles) and their
parameters.

Use chunked field storage \\
Field chunk size or range

%-----------------------------------------------------------------------
\subsection{Concurrency parameters} 
%-----------------------------------------------------------------------

Specifiy method for controling parallelism

   parallelization method (MPI buffered/blocking, MPI2 Get)


%-----------------------------------------------------------------------
\subsection{I/O parameters} 
%-----------------------------------------------------------------------

Output types and parameters
 checkpoint (dump all)
 output (specific fields)
 movies (type and rate)
 analysis (type of analysis, rate)
 level of output (files for timestep, time, etc.)


%-----------------------------------------------------------------------
\subsection{Performance parameters} 
%-----------------------------------------------------------------------

Performanec parameters control \lcaperf\ instrumentation.



%=======================================================================
\section{Classes} \label{s:classes}
%=======================================================================

\begin{itemize}
\item Parameters
\item Domain
\item BC
\item IC
\item Problem
\item Array
\item Box
\item Hierarchy
\item Level
\item Grid
\item Tree
\item Field
\item Units
\item Constants
\end{itemize}

%-----------------------------------------------------------------------
\subsection{\code{Parameters} class}
%-----------------------------------------------------------------------

The \code{Parameters} class read in a parameter file or files, and
provide the application access to parameter values.


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Domain} class}
%-----------------------------------------------------------------------

The \code{Domain} class defines the problem domain


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{BC} class}
%-----------------------------------------------------------------------

The \code{BC} class defines boundary conditions on a \code{Domain}.



\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{IC} class}
%-----------------------------------------------------------------------

The \code{IC} class defines initial conditions for a set of
\code{Field}s in a \code{Domain}.


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Problem} class}
%-----------------------------------------------------------------------

The \code{Problem} class defines the problem to be solved, including
the domain, boundary conditions, and initial field values.


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Array} class}
%-----------------------------------------------------------------------

The \code{Array} class encapsulates Fortran-style arrays with
convenience operations.  \code{Array}s may have optional support for
storing blocked or chunked arrays, include array padding, or store
interleaved arrays.

\textbf{Array shape.}

\textbf{Array blocking.}

\textbf{Array padding.}

\textbf{Array interleaving.}


\subsubsection{Attributes}

\subsubsection{Operations}


\begin{tabbing}
xxxx\=xx\=xxxxxxxxxxxxxxxxxxxxxxxx\= \kill
\> \todo \> \code{Array()} \> \textit{Create an uninitialized array} \\
\> \todo \> \code{allocate()} \> \textit{Allocate storage for an array.} \\
\> \todo \> \code{deallocate()} \> \textit{Deallocate storage for an array} \\
\> \todo \> \code{set\_shape (int d, int * size)}  \> \textit{Set the shape of an array to the given size} \\
\> \todo \> \code{set\_blocking (int d, int * size)}  \> \textit{Set subblocks to given size} \\
\> \todo \> \code{set\_padding (int d, int * size)}  \> \textit{Set array padding} \\
\> \todo \> \code{interleave (int num, Array * arrays)}  \> \textit{Interleave multiple arrays} \\
\end{tabbing}


%-----------------------------------------------------------------------
\subsection{\code{Box} class}
%-----------------------------------------------------------------------

The \code{Box} class is for representing a box, and provides KeLP-like functionality.
Boxes are determined by two points, which may be of any parameterized type
(e.g.~\code{int} or \code{double}, etc.).


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Hierarchy} class}
%-----------------------------------------------------------------------

A \code{Hierarchy} class represents a distributed structured AMR grid
hierarchy.  A \code{Hierarchy} can be considered to be composed of
\code{Level}s, which are in turn composed of \code{Grid}s; or a \code{Hierarchy}
can be considered to be composed of a set of \code{Tree}s.


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Level} class}
%-----------------------------------------------------------------------

A \code{Level} class represents a level in a distributed structured
AMR grid hierarchy (\code{Hierarchy}, where a level is defined as all
grid patches (\code{Grid}s) that have the same resolution.  A \code{Level}
is usually contained in a \code{Hierarchy}.

% The AMR hierarchy is represented using the trio of classes
% \code{Hierarchy}, \code{Level}, and \code{Grid}.
%   A \code{Grid} is a
% box in space, and is decomposed into \code{GridLocal} and
% \code{GridRemote} classes (see \S\ref{sss:class-grid}).  Each
% \code{GridLocal} object has some number of \code{Field} objects
% associated with them (see \S\ref{sss:class-field}), though the
% \code{GridLocal} objects themselves do not store field data
% themselves.  A \code{Level} class is also either a ``structured''
% \code{LevelStruct} or an ``unstructured'' \code{LevelUnstruct}.
% Structured levels are composed of a regular array of \code{Grid}s, and
% is typically used for unigrid calculations or the root level of an AMR
% calculation.  Unstructured levels are typically used for non-root
% levels of an AMR calulation.

\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Tree} class}
%-----------------------------------------------------------------------

A \code{Tree} class represents a tree in a distributed structured AMR
grid hierarchy (\code{Hierarchy}), where a tree is defined as a grid patch
in a hierarchy, together with all of its descendents, up to a specified
level.


\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Grid} class}
%-----------------------------------------------------------------------

A \code{Grid} class represents a grid patch in a distributed structured
AMR grid hierarchy (\code{Hierarchy}).  A \code{Grid} is defined by a
\code{Box}, a \code{ProcessorGroup}, and a size which determines
the size of \code{Array}s defined on the \code{Grid}.  Each
\code{Grid} is contained in a \code{Level}.

\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Field} class}
%-----------------------------------------------------------------------

A \code{Field} represents a discrete multiresolution scalar or vector
field.  A \code{Field} is associated with a \code{Hierarchy}, and is
composed of \code{Array}'s defined on a subset of \code{Grid}s in the
\code{Hierarchy}.

\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Units} class}
%-----------------------------------------------------------------------

A \code{Units} class represents the physical units for the data in a
\code{Field}.

\subsubsection{Attributes}

\subsubsection{Operations}

%-----------------------------------------------------------------------
\subsection{\code{Constants} class}
%-----------------------------------------------------------------------

The \code{Constants} class contains physical constants used throughout
\cello.  It is declared as static.

\subsubsection{Attributes}

\subsubsection{Operations}

%==================================================================
\end{document}
%==================================================================

