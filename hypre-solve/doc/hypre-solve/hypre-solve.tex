%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%
% Overview
% Problem definition
%   Multilevel Poisson solver
%   Multilevel diffusion solver
% Linear solvers
%   CG / BiCGStab
%   FAC
%   [smoothing]
%   [MLC]
%   hypre package
%
% Current Enzo Poisson Solver
%   method
%     Overlapping Schwarz
%       fft on coarse (periodic only)
%       mg on non-coarse
%   issues
%     global accuracy
%     accuracy at grid boundaries
%     adaptive timestepping
%   implementation
%     files
%     functions
%     pseudocode
%
% Proposed Enzo Poisson Solver
%
% Solver development
%   overview
%      uml of solver: Enzo + hypre-solve + hypre
%      1. develop external solver module ``hypre-solve''
%         rationale: controlled testing, sanity, etc.
%      2. integrate with Enzo
%   hypre-solve module
%     overview
%     issues
%     requirements
%       list of capabilities
%       list of current limitations
%     design
%     implementation
%        files
%        classes
%        interface
%     
%   Enzo integration
%     issues
%       adjacent grid in nonadjacent levels
%     implementation
%        hypre-solve interface
%        files
%        classes
%       
%     


\documentclass[10pt]{article}

\include{include}

%==================================================================
% Margins and spacing
%==================================================================

\begin{document}

%=======================================================================
\TITLE{Multilevel Linear Solvers in \enzo \\ \large new (radiation) and improved (self-gravity)}
      {James Bordner}{$Rev$}
%=======================================================================

\tableofcontents

%======================================================================
\section{Overview}
%======================================================================

%----------------------------------------------------------------------
\subsection{Problem statement}
%----------------------------------------------------------------------

multilevel Poisson solver

multilevel diffusion solver

%======================================================================
\section{Current \enzo\ Poisson Solver}
%======================================================================

\note{testing deferred to end to compare with new solver}

%----------------------------------------------------------------------
\subsection{Method}
%----------------------------------------------------------------------
  \pargraph{overlapping schwarz}
  \pargraph{FFT on coarse (periodic only)}
  \pargraph{MG on non-coarse patches}
%----------------------------------------------------------------------
\subsection{Implementation}
%----------------------------------------------------------------------

\code{PrepareDensityField()}
\code{grid::SolveForPotential()}
\code{ComputeAccelerationFieldExternal()}

\code{SetAccelerationBoundary()}

\code{DeleteAccelerationField()}

\code{GRAVITY\_SECOND\_ORDER\_CORRECTION} in \code{euler.src}

\question{\code{euler.src}:592---why turned is GRAVITY\_SECOND\_ORDER\_CORRECTION in  turned off}

\question{\code{EvolveLevelRoutinesOptimized.C:74---why is the communication ordering send first then receive?}}

  \pargraph{pseudo-code}


\begin{tabbing}
xxxxx\=xxxxx\=xxxxx\=xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\codebf{PrepareDensityField()} \\
\> \\
\> \code{GenerateGridArray()} \\
\> \code{DepositParticleMassfield()} \textit{send + recv} \\
\> \code{PrepareGravitatingMassField()} \textit{send + recv} \\
\> \code{CheckForOverlap()} \textit{send + recv} \\
\> \code{if (level $==$ 0)} \\
\>\> \code{ComputePotentialFieldLevelZero()} \\
\> \code{else} \\
\>\> \code{SolveForPotential()} \\
\>\> \code{CheckForOverlap()} \\
\> \code{if (level $>$ max)} \\
\>\>   \code{SolveForPotential()} \\
\>\>   \code{CopyPotentialToBaryonField()} \\
\>\>   \code{ComputeAccelerationField()} \\
\> \code{if (! CopyGravPotential)} \\
\>\>   \code{InterpolateAccelerations()} \\
\end{tabbing}

  \pargraph{Files}
  \pargraph{functions}
%----------------------------------------------------------------------
\subsection{Issues}
%----------------------------------------------------------------------
   \pargraph{global accuracy: coarse-to-fine data movement only}
   \pargraph{gradient jumps on grid-patch boundaries}
   \pargraph{subcycling}
   \pargraph{interfacing hyperbolic with elliptic}

%======================================================================
\section{New \enzo\ Solver: \hypresolve}
%======================================================================

\note{Approaches}

   \pargraph{implement solver directly}
     \note{a lot of work}
     \note{solver technology active research area}
     \note{best to call library}
   \pargraph{have \enzo\ call \hypre\ directly}
     \note{\hypre\ supports AMR and is designed to be highly scalable}
     \note{having \enzo\ call \hypre\ directly would be difficult}
     \note{code complexity, interfacing datastructures, code layout of \enzo, testing}
     \note{want interface code that calls \hypre, provides high-level
           API to \enzo, and can be tested independently}
   \pargraph{have \enzo\ call \hypre\ through intermediate code}
     \note{Create ``hypre-solve''}
     \note{initially developed independent of \enzo}
     \note{Provides high-level functions: ``attach to'' and ``detach from'' \enzo's datastructures, level and hierarchy solves}
     \note{independently testable}
     \note{\hypresolve, described next}


% %======================================================================
% \section{Roadmap and Milestones}
% %======================================================================
% 
% 
% \begin{description}
% \item[Driver: ] \code{hypre-solve} (H), \enzo\ (E)
% \item[Equation: ] Poisson (P), diffusion equation (D)
% \item[Datastructure: ] Unigrid (U), AMR (A)
% \item[AMR refinement: ] $R=2$ (2), $R=2^k$ (2k), arbitrary $R$ (*)
% \item[AMR discretization: ] $D=1$, $D=3$, $D=4$, $D=6$
% \end{description}
% 
% \begin{tabular}{cl|cc|cc|cc|ccc|ccc}
% Done & \multicolumn{1}{c}{Description} & H&E & P&D & U&A & 2&[2k]&[*] & C&[L]&[Q] \\ \hline
% \multicolumn{2}{l|}{Basic Poisson} &&&&&&&&& \\
% \done & Unigrid Poisson equation & \done&\todo & \done&\todo & \done&\todo & \done&\todo&\todo & \done&\todo&\todo \\
% \todo &AMR Poisson equation  & \done&\todo & \done&\todo & \todo&\done & \done&\todo&\todo & \done&\todo&\todo \\ \hline
% \multicolumn{2}{l|}{Basic diffusion} &&&&&&&&& \\
% \todo &Unigrid Diffusion equation& \done&\todo & \todo&\done& \done&\todo & \done&\todo&\todo & \done&\todo&\todo  \\
% \todo  &AMR Diffusion equation& \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \done&\todo&\todo \\  \hline
% \multicolumn{2}{l|}{higher-order discretizations} &&&&&&&&& \\
% \todo  &piecewise linear Poisson & \done&\todo & \done&\todo & \todo&\done & \done&\todo&\todo & \todo&\done&\todo \\
% \todo  &  piecewise linear Diffusion & \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \todo&\done&\todo \\  
% \todo &piecewise quadratic Poisson & \done&\todo & \done&\todo& \todo&\done & \done&\todo&\todo & \todo&\todo&\done \\  
% \todo &piecewise quadratic Diffusion & \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \todo&\todo&\done \\  \hline
% \multicolumn{2}{l|}{more general refinement factors} &&&&&&&&& \\
% \todo &$2^k$ refinement factors  & \done&\todo & \todo&\done& \todo&\done & \todo&\done&\todo & \done&\todo&\todo\\
% \todo & arbitrary refinement factors & \done&\todo & \todo&\done& \todo&\done & \todo&\todo&\done & \done&\todo&\todo \\  \hline
% \multicolumn{2}{l|}{\enzo\ port} &&&&&&&&& \\
% \todo &port to \enzo & \todo&\done & \fade&\fade& \fade&\fade & \fade&\fade&\fade & \fade&\fade&\fade
% \end{tabular}



%-----------------------------------------------------------------------
\subsection{The \code{hypre-solve} \enzo---\hypre\ interface}  \label{ss:hypre-solve}
%-----------------------------------------------------------------------

   \hypresolve\ will be used as a testbed for experimenting with the
   parallel solution of linear systems arising from self-gravity
   (Poisson equation) and radiation transfer algorithms (diffusion
   equation) defined on distributed SAMR hierarchies.  \hypresolve\
   will also be the primary interface code linking the \enzo\
   datastructures with the \hypre\ linear solver package.  The purpose
   of this document is to specify the requirements, describe the
   design and implementation, and present test results for
   \hypresolve.

   We decompose the standalone solver into two components: problem
   generation (\code{hypre-init}), and problem solution
   (\code{hypre-solve}).  \code{hypre-init} takes as input parameters
   describing the problem characteristics in general terms, such as
   bounds on grid sizes, number of processors, description of how to
   distribute point masses, etc.  The output is a file of parameters
   that specify the exact problem to solve, including grid locations,
   sizes, levels, point mass locations, etc.  The file output by
   \code{hypre-init} can be subsequently read by \code{hypre-solve}.
   \code{hypre-solve} calls \hypre\ to generate and solve a
   distributed linear system, and the solution, performance
   information, solver efficiency information, etc., are output.


%-----------------------------------------------------------------------
\subsection{Using \hypresolve\ outside of \enzo}
%-----------------------------------------------------------------------

The following table lists the input parameters to \code{hypre-solve}.  

\newcommand{\parmentry}[3]{
\codebf{#1} \textit{#2} \\ \mbox{\ \ \ \ }#3. \\}


\parmentry{dimension}{dimension}
   {Define the problem dimension}
\parmentry{domain}{dimension vertex-lower vertex-upper}
   {Specify the problem domain}
\parmentry{boundary}{\{\code{dirichlet} $|$ \code{periodic}\}}
   {Specify the boundary conditions}
\parmentry{point}{mass position}
   {Create a point-mass in the domain}
\parmentry{grid}{id parent-id processor vertex-lower vertex-upper index-lower zone-count}
   {Define a grid patch}
\parmentry{discret}{\{\code{constant} $|$ \code{linear} $|$ \code{bilinear} $|$ \code{quadratic}\}}
   {Select which discretization method to use (currently only ``constant'' is implemented)}
\parmentry{solver}{\{\code{fac} $|$ \code{pfmg} $|$ \code{bicgstab} $|$ \code{gmres}\}}
   {Select which \hypre\ solver to use}
\parmentry{solver\_itmax}{iterations}
   {Optionally set the number of solver iterations}
\parmentry{solver\_restol}{tolerance}
   {Optionally set the stopping tolerance of the relative residual for the solver}
\parmentry{enzo\_interface}{\{\code{file} $|$ \code{attach}\}}
   {Whether to read the density field from an \enzo\ data dump, or attach to \enzo\ density fields directly}
\parmentry{enzo\_packed}{\{\code{true} $|$ \code{false}\}}
   {Whether \enzo\ data dump is in packed format or not}
\parmentry{enzo\_prefix}{prefix}
   {Prefix for the \enzo\ data dump}


The output of \code{hypre-solve} is a file containing the following:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxx\=\kill
\> \todo\ \code{flops-balance} \>    \textit{Load balance efficiency with respect to flops}\\
\> \todo\ \code{flops-proc-avg} \> \textit{Average flop counts over processors} \\
\> \todo\ \code{flops-proc-max} \> \textit{Maximum flop counts over processors} \\
\> \todo\ \code{flops-total} \> \textit{Number of floating point operations} \\
\> \todo\ \code{mem-balance} \>    \textit{Load balance efficiency with respect to memory}\\
\> \todo\ \code{mem-proc-avg} \> \textit{Average memory usage over processors} \\
\> \todo\ \code{mem-proc-max} \>    \textit{Maximum memory usage over processors} \\
\> \todo\ \code{mem-total} \> \textit{Amount of memory used} \\
\> \todo\ \code{procs-total} \> \textit{Number of processors} \\
\> \todo\ \code{time-total} \>  \textit{Time to solution}
\end{tabbing}

The solution, and optionally matrix and right-hand side, are output in both
\hypresolve\ format and \hypre\ format.

% hypre-init and enzo2hypre

For testing \hypresolve, two utilities were created, \hypreinit\ and
\enzotohypre.  The first, \hypreinit, creates a \hypresolve\ input file defining
a problem with a single point source, either centered or offset.
Parameters to \hypreinit\ include the coarse-grid problem size, number
of processors, number of levels, whether to run as serial or parallel,
boundary conditions, and which \hypre\ solver to call.  The second,
\enzotohypre, reads the \code{Density} field of an \enzo\ dump
directory and generates a corresponding \hypresolve\ input file.

%-----------------------------------------------------------------------
\subsection{\hypresolve\ design} \label{sss:design}
%-----------------------------------------------------------------------

The \code{main()} function is in \code{hypre-solve.cpp}.  Functions
are roughly grouped into four phases: 1) read the problem input file,
2) create the hierarchy data-structure; 3) call \hypre\ to create its
linear system data-structures; and 4) call \hypre\ to solve the linear
system.

\begin{tabbing}
xxxxx\=xxxxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\textit{\underline{hypre-solve.cpp}} \\
\\
\code{\textbf{main()}} \\
\{ \\
\> \comment{Initialize the problem} \\
\\
\> \code{problem.read()} \\
\>\> \code{hierarchy.insert\_grid()} \> \comment{Add a grid to the list of grids}\\
\\
\> \comment{Initialize the hierarchy} \\
\\
\> \code{hierarchy.initialize()} \\
\>\>  \code{init\_grid\_parents\_()} \> \comment{Set parent pointers}\\
\>\>  \code{init\_grid\_levels\_()}  \> \comment{Determine grid levels from parent info} \\
\>\>  \code{init\_grid\_children\_()} \> \comment{Find grid children from parent info} \\
\>\>  \code{init\_grid\_neighbors\_()} \> \comment{Find grid neighbors} \\
\>\>  \code{init\_indices\_()} \> \comment{Determine the problem size the hard way} \\
\>\>  \code{init\_grid\_faces\_()} \> \comment{Categorize grid face zones for local grids and neighbors} \\
\\
\> \comment{\hypre\ setup} \\
\\
\> \code{hypre.init\_hierarchy()} \>\> \comment{Initialize \hypre\ Grid} \\
\> \code{hypre.init\_stencil()} \>\> \comment{Initialize \hypre's Stencils} \\
\> \code{hypre.init\_graph()} \>\> \comment{Initialize \hypre's Graph} \\
\> \code{hypre.init\_linear()} \>\> \comment{Initialize \hypre's matrix and vectors} \\
\\
\> \comment{Call \hypre\ to solve the linear system} \\
\\
\> \code{hypre.solve()} \\
\\
\> \comment{Evaluate and report on the solve} \\
\\
\> \code{hypre.evaluate()} \\
\}
\end{tabbing}


\subsubsection{\code{hypre.init\_hierarchy()}}


For each grid patch it owns, each processor creates a \hypre\ grid
object defining the grid's extents and variables.  

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructGridCreate()} 
   \> \textit{Creates the \hypre\ grid hierarchy datastructure} \\
\>  \done\ \code{HYPRE\_SStructGridSetExtents()}
   \> \textit{Sets the extents for each processor-local patch} \\
\> \done\ \code{HYPRE\_SStructGridSetVariables()}
   \> \textit{Sets variables to be cell-centered for each level} \\
\> \done\ \code{HYPRE\_SStructGridSetPeriodic()}
   \> \textit{Set problem periodicity} \\
\> \done\ \code{HYPRE\_SStructGridAssemble()}
   \> \textit{Finalize the \hypre\ grid hierarchy datastructure}
\end{tabbing}

Neighboring grids do not need to be set using \hypre's
\code{HYPRE\_SStructGridSetNeighborBox()} function, since grids within an AMR
level are in the same \hypre\ ``part''.  However, since \hypresolve\
needs to know which zones in a grid are adjacent to neighboring grid
zones for setting up the inter-level grid elements, \hypresolve\ has
its own version of \code{HYPRE\_SStructGridSetNeighborBox()}.

%-----------------------------------------------------------------------
\subsubsection{\code{hypre.init\_stencil()}}


  Create the stencil object which defines the matrix nonzeros within each grid.

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructStencilCreate()}
   \> \textit{Creates the \hypre\ grid stencil} \\
\> \done\ \code{HYPRE\_SStructStencilSetEntry()}
   \> \textit{Defines the seven stencil zones}
\end{tabbing}

%-----------------------------------------------------------------------
\subsubsection{\code{hypre.init\_graph()}}


 Each processor creates a graph containing the non-zero structure of
 the matrix.

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructGraphCreate()}
   \> \textit{Creates the \hypre\ graph} \\
\> \done\ \code{HYPRE\_SStructGraphSetStencil()}
   \> \textit{Define the stencil for each part (level) of the grid} \\
\> \done\ \code{HYPRE\_SStructGraphAddEntries()}
   \> \textit{Add non-stencil entries for each inter-part connection in the grid} \\
\> \done\ \code{HYPRE\_SStructGraphAssemble()}
   \> \textit{Finalize the \hypre\ graph}
\end{tabbing}

%-----------------------------------------------------------------------
\subsubsection{\code{hypre.init\_linear()}}


\hypre\ subroutines are called to create
a new matrix $A$ and vectors $B$ and $X$.  \hypre\ vectors are
created and initialized using the following \hypre\ functions:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructVectorCreate()}
   \> \textit{Create the \hypre\ vector} \\
\> \done\ \code{HYPRE\_SStructVectorSetObjectType()}
   \> \textit{Set the \hypre\ vector storage type} \\
\> \done\ \code{HYPRE\_SStructVectorInitialize()}
   \> \textit{Initializes the \hypre\ vector datastructure} \\
\> \done\ \code{HYPRE\_SStructVectorGetBoxValues()}
   \> \textit{Read a subset of the \hypre\ vector elements} \\
\> \done\ \code{HYPRE\_SStructVectorAddToBoxValues()}
   \> \textit{Increment a subset of the \hypre\ vector elements} \\
\> \done\ \code{HYPRE\_SStructVectorAssemble()}
   \> \textit{Assemble the \hypre\ vector} \\
\> \done\ \code{HYPRE\_SStructVectorPrint()}
   \> \textit{Write the vector to a file}
\end{tabbing}

The \hypre\ matrix $A$ is created and initialized
using the following \hypre\ functions:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructMatrixCreate()}
   \> \textit{Create the \hypre\ matrix} \\
\> \done\ \code{HYPRE\_SStructMatrixSetObjectType()}
   \> \textit{Set the \hypre\ matrix storage type} \\
\> \done\ \code{HYPRE\_SStructMatrixInitialize()}
   \> \textit{Initialize the  \hypre\ matrix} \\
\> \done\ \code{HYPRE\_SStructMatrixSetBoxValues ()}
   \> \textit{Set the \hypre\ matrix stencil element values} \\
\> \done\ \code{HYPRE\_SStructMatrixAddToValues()}
   \> \textit{Increment matrix non-stencil element values} \\
\> \done\ \code{HYPRE\_SStructMatrixAssemble()}
   \> \textit{Finalize the \hypre\ matrix} \\
\> \done\ \code{HYPRE\_SStructMatrixPrint()}
   \> \textit{Write the matrix to a file} \\
\> \done\ \code{HYPRE\_SStructFACZeroAMRMatrixData()}
   \> \textit{Clear matrix elements underneath fine-grid patches}
\end{tabbing}

Details of defining the matrix elements are deferred to \S\ref{ss:discretization}.

%-----------------------------------------------------------------------
\subsubsection{\code{hypre.solve()}}


Three \hypre\ solvers are implemented in \code{hypre-solve}:
pre-conditioned full multigrid (PFMG) which is applicable to
single-level grid ``hierarchies'' only; full-adaptive composite
multigrid method (FAC), which is applicable to multi-level grid
hierarchies only, and BiCGSTAB, a non-symmetric generalization of the
conjugate gradient method, which is applicable to either single- or
multi-level grid hierarchies.

The \hypre\ functions used when solving the linear system using
the PFMG solver are listed below:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructSysPFMGCreate}
   \> \textit{Creates the \hypre\ PFMG solver} \\
\> \done\ \code{HYPRE\_SStructSysPFMGSetMaxIter}
   \> \textit{Sets the maximum number of iterations} \\
\> \done\ \code{HYPRE\_SStructSysPFMGSetTol}
   \> \textit{Sets the tolerance for the stopping criteria} \\
\> \done\ \code{HYPRE\_SStructSysPFMGSetLogging}
   \> \textit{Set solver to log information} \\
\> \done\ \code{HYPRE\_SStructSysPFMGSetup}
   \> \textit{Prepare the solver to be used} \\
\> \done\ \code{HYPRE\_SStructSysPFMGSolve}
   \> \textit{Apply the solver to the linear system} \\
\> \done\ \code{HYPRE\_SStructSysPFMGGetNumIterations}
   \> \textit{Obtain the number of iterations used} \\
\> \done\ \code{HYPRE\_SStructSysPFMGGetFinalRelativeResidualNorm}
   \> \textit{Obtain the final residual norm} \\
\> \done\ \code{HYPRE\_SStructSysPFMGDestroy}
   \> \textit{Delete the solver when finished}
\end{tabbing}

The \hypre\ functions used when solving the linear system using
the FAC solver are listed below:

 \begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructFACCreate}
   \> \textit{Creates the \hypre\ FAC solver} \\
\> \done\ \code{HYPRE\_SStructFACSetMaxLevels}
   \> \textit{Set the maximum number of grid levels} \\
\> \done\ \code{HYPRE\_SStructFACSetPLevels}
   \> \textit{Set the mapping between parts and levels} \\
\> \done\ \code{HYPRE\_SStructFACSetPRefinements}
   \> \textit{Set the refinement factors} \\
\> \done\ \code{HYPRE\_SStructFACSetNumPreRelax}
   \> \textit{Set the number of pre-relaxation sweeps} \\
\> \done\ \code{HYPRE\_SStructFACSetNumPostRelax}
   \> \textit{Set the number of post-relaxation sweeps} \\
\> \done\ \code{HYPRE\_SStructFACSetCoarseSolverType}
   \> \textit{Set the coarse solver} \\
\> \done\ \code{HYPRE\_SStructFACSetRelaxType}
   \> \textit{Set the relaxation sweep type} \\
\> \done\ \code{HYPRE\_SStructFACSetMaxIter}
   \> \textit{Set the maximum number of iterations} \\
\> \done\ \code{HYPRE\_SStructFACSetTol}
   \> \textit{Set the tolerance for the stopping criteria} \\
\> \done\ \code{HYPRE\_SStructFACSetLogging}
   \> \textit{Set to log information} \\
\> \done\ \code{HYPRE\_SStructFACSetup2}
   \> \textit{Prepare the solver to be used} \\
\> \done\ \code{HYPRE\_SStructFACSolve3}
   \> \textit{Apply the solver to the linear system} \\
\> \done\ \code{HYPRE\_SStructFACGetNumIterations}
   \> \textit{Obtain the number of iterations used} \\
\> \done\ \code{HYPRE\_SStructFACGetFinalRelativeResidualNorm}
   \> \textit{Obtain the final residual norm} \\
\> \done\ \code{HYPRE\_SStructFACDestroy2}
   \> \textit{Delete the solver when finished}
\end{tabbing}

The \hypre\ functions used when solving the linear system using
the BiCGSTAB solver are listed below:

 \begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{HYPRE\_SStructBiCGSTABCreate}
   \> \textit{Creates the \hypre\ BiCGSTAB solver} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABSetMaxIter}
   \> \textit{Set the maximum number of iterations} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABSetTol}
   \> \textit{Set the stopping criteria tolerance} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABSetLogging}
   \> \textit{Set to log information} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABSetup}
   \> \textit{Prepare the solver to be used} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABSolve}
   \> \textit{Apply the solver to the linear system} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABGetNumIterations}
   \> \textit{Obtain the number of iterations used} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABGetFinalRelativeResidualNorm}
   \> \textit{Obtain the final residual norm} \\
\> \done\ \code{HYPRE\_SStructBiCGSTABDestroy}
   \> \textit{Delete the solver when finished}
\end{tabbing}

%-----------------------------------------------------------------------
%\subsubsection{\code{hypre.evaluate()}}

%-----------------------------------------------------------------------
\subsection{Classes} \label{ss:classes}
%-----------------------------------------------------------------------

C++ classes used in \code{hypre-solve} are summarized below:


 \begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \done\ \code{Constants	}
  \> \textit{Class for storing physical constants} \\
\> \done\ \code{Domain	}
  \> \textit{Class for representing the problem domain} \\
\> \done\ \code{Faces	}
  \> \textit{Class for storing grid face zone types and neighbors} \\
\> \done\ \code{Grid	}
  \> \textit{Class for storing physical constants} \\
\> \done\ \code{Hierarchy	}
  \> \textit{Class for representing a grid patch} \\
\> \done\ \code{Hypre	}
  \> \textit{Class for encapsulating the interface to \hypre} \\
\> \done\ \code{ItGridChildren	}
  \> \textit{Class for iterating over child grids of a grid} \\
\> \done\ \code{ItGridNeighbors	}
  \> \textit{Class for iterating over neighboring grids of a grid} \\
\> \done\ \code{ItHierarchyGridsAll	}
  \> \textit{Class for iterating over all grids in the hierarchy} \\
\> \done\ \code{ItHierarchyGridsLocal	}
  \> \textit{Class for iterating over all processor-local grids in the hierarchy} \\
\> \done\ \code{ItHierarchyLevels	}
  \> \textit{Class for iterating over all levels in the hierarchy (coarsest first)} \\
\> \done\ \code{ItHierarchyLevelsReverse	}
  \> \textit{Class for iterating over levels in the hierarchy (finest first)} \\
\> \done\ \code{ItLevelGridsAll	}
  \> \textit{Class for iterating over all grids in a level} \\
\> \done\ \code{ItLevelGridsLocal	}
  \> \textit{Class for iterating over all processor-local grids in a level} \\
\> \done\ \code{ItParameters	}
  \> \textit{Class for iterating over all input parameters} \\
\> \done\ \code{Level	}
  \> \textit{Class for encapsulating a single hierarchy level} \\
\> \done\ \code{Mpi	}
  \> \textit{Class for encapsulating the interface to MPI} \\
\> \done\ \code{Parameters	}
  \> \textit{Class for storing input parameters} \\
\> \done\ \code{Point	}
  \> \textit{Class for storing a physical point mass} \\
\> \done\ \code{Problem	}
  \> \textit{Class for representing the problem to solve} \\
\end{tabbing}


%-----------------------------------------------------------------------
\subsection{Discretization} \label{ss:discretization}
%-----------------------------------------------------------------------

\newcommand{\indvar}{r}
 \newcommand{\uc}{u(\indvar)}
 \newcommand{\uv}{u(\volel)}
 \newcommand{\us}{u(\surfel)}

 \newcommand{\uxp}{u(\indvar+h_x)}
 \newcommand{\uxm}{u(\indvar-h_x)}
 \newcommand{\uxph}{u(\indvar+\frac{h_x}{2})}
 \newcommand{\uxmh}{u(\indvar-\frac{h_x}{2})}

 \newcommand{\uyp}{u(\indvar+h_y)}
 \newcommand{\uym}{u(\indvar-h_y)}
 \newcommand{\uyph}{u(\indvar+\frac{h_y}{2})}
 \newcommand{\uymh}{u(\indvar-\frac{h_y}{2})}

 \newcommand{\uzp}{u(\indvar+h_z)}
 \newcommand{\uzm}{u(\indvar-h_z)}
 \newcommand{\uzph}{u(\indvar+\frac{h_z}{2})}
 \newcommand{\uzmh}{u(\indvar-\frac{h_z}{2})}

 \newcommand{\norm}{\textbf{n}}

 \newcommand{\ac}{a(\indvar)}
 \newcommand{\av}{a(\volel)}
 \newcommand{\as}{a(\surfel)}

 \newcommand{\fc}{f(\indvar)}
 \newcommand{\fv}{f(\volel)}
 \newcommand{\fs}{f(\surfel)}

 \newcommand{\axph}{a(\indvar+h_x/2)}
 \newcommand{\axmh}{a(\indvar-h_x/2)}
 \newcommand{\ayph}{a(\indvar+h_y/2)}
 \newcommand{\aymh}{a(\indvar-h_y/2)}
 \newcommand{\azph}{a(\indvar+h_z/2)}
 \newcommand{\azmh}{a(\indvar-h_z/2)}

 \newcommand{\axpH}{a(\indvar+H_x/2)}

 \newcommand{\alc}{\alpha_{0}}
 \newcommand{\alxp}{\alpha_{x}}
 \newcommand{\alxm}{\alpha_{\bar{x}}}
 \newcommand{\alyp}{\alpha_{y}}
 \newcommand{\alym}{\alpha_{\bar{y}}}
 \newcommand{\alzp}{\alpha_{z}}
 \newcommand{\alzm}{\alpha_{\bar{z}}}

 \newcommand{\Uc}{U_{0}}
 \newcommand{\Uxp}{U_{x}}
 \newcommand{\Uxm}{U_{\bar{x}}}
 \newcommand{\Uyp}{U_{y}}
 \newcommand{\Uym}{U_{\bar{y}}}
 \newcommand{\Uzp}{U_{z}}
 \newcommand{\Uzm}{U_{\bar{z}}}
 \newcommand{\F}{F}

 \newcommand{\vol}{{\Omega_h}}
 \newcommand{\volel}{\textbf{V}}
 \newcommand{\surf}{\partial\vol}
 \newcommand{\surfel}{\textbf{S}}
 \newcommand{\sidexp}{\partial\Omega_h^{+x}}
 \newcommand{\sidexm}{\partial\Omega_h^{-x}}
 \newcommand{\sideyp}{\partial\Omega_h^{+y}}
 \newcommand{\sideym}{\partial\Omega_h^{-y}}
 \newcommand{\sidezp}{\partial\Omega_h^{+z}}
 \newcommand{\sidezm}{\partial\Omega_h^{-z}}

 \newcommand{\sideXP}{\partial\Omega_H^{+x}}


We wish to discretize $\nabla\cdot(\ac \nabla \uc) = f$
on a structured AMR hierarchy with arbitrary refinement factor $r$
between successive levels.  This task can be broken down into
discretizing within a uniform grid level, between grid patches in
adjacent hierarchy levels, and at the domain boundary.  
We consider discretizing within levels in
\S\ref{ss:discret-unigrid}, between
levels in \S\ref{ss:discret-amr}, and at the domain boundary in
\S\ref{ss:discret-boundary}.

%-----------------------------------------------------------------------
\subsection{Discretization within grid patches} \label{ss:discret-unigrid}
%-----------------------------------------------------------------------

We wish to discretize the diffusion equation $\nabla\cdot(\ac \nabla
\uc) = f$ within a $3$D grid.  We assume uniform
grid spacing $h_{x} = h_{y} = h_{z}$ within the grid.  To simplify
visualization, the figure below represents the $2$D analog of the $3$D
problem.  The unknowns $u(r)$, (located at the ``$\Box$'' marks in the
figure) are located at cell centers, and the known coefficients $a(r)$
(located at the ``$\circ$'' marks in the figure) are evaluated at cell
faces.  The black unknown in the figure depends on the grey unknowns
and grey coefficients.  For the special case of the Poisson equation,
$a(r)\equiv 1$.

\begin{center}
\begin{minipage}{1.5in}
\epsfig{file=fig/stencil.eps,width=1.5in}
\end{minipage} 
\end{center}

First we integrate over the $h_x \times h_y \times h_z$ cell $\vol$
centered at $r$, and apply the divergence rule:

 \begin{eqnarray*}
 \nabla\cdot(\ac \nabla \uc) & = & \fc \\
 \int_\vol \nabla\cdot(\av \nabla \uv)\, d\volel & = & \int_\vol \fv\, d\volel \\
 \oint_{\surf} \as \nabla \us\cdot \norm \, d\surfel & = & \int_\vol \fv\, d\volel
 \end{eqnarray*}

Next we break up the surface integral over the cell surface $\surf$
into separate integrals over each of the six cell faces
$\sidexp,\sidexm,\sideyp,\sideym,\sidezp$ and $\sidezm$:

 \begin{eqnarray*}
 \oint_{\sidexp} \as \nabla \us\cdot \norm \, d\surfel +  \oint_{\sidexm} \as \nabla \us\cdot \norm \, d\surfel & + & \\
 \oint_{\sideyp} \as \nabla \us\cdot \norm \, d\surfel +  \oint_{\sideym} \as \nabla \us\cdot \norm \, d\surfel & + & \\
 \oint_{\sidezp} \as \nabla \us\cdot \norm \, d\surfel +  \oint_{\sidezm} \as \nabla \us\cdot \norm \, d\surfel & = & \int_\vol \fv\, d\volel
 \end{eqnarray*}

Next we approximate the surface and volume integrals using the
midpoint rule, and approximate the derivatives using a centered difference:

 \begin{eqnarray*}
 |\sidexp| \axph \frac{du}{dx}(r+h_x/2) + 
 |\sidexm| \axmh \frac{du}{dx}(r-h_x/2) & + & \\ 
 |\sideyp| \ayph \frac{du}{dy}(r+h_y/2) +
 |\sideym| \aymh \frac{du}{dy}(r-h_y/2) & + & \\ 
 |\sidezp| \azph \frac{du}{dz}(r+h_z/2) + 
 |\sidezm| \azmh \frac{du}{dz}(r-h_z/2) & = & |\vol| \fc  \\
\\
 h_y h_z \axph \frac{du}{dx}(r+h_x/2) + 
 h_y h_z \axmh \frac{du}{dx}(r-h_x/2) & + & \\ 
 h_z h_x \ayph \frac{du}{dy}(r+h_y/2) +
 h_z h_x \aymh \frac{du}{dy}(r-h_y/2) & + & \\ 
 h_x h_y \azph \frac{du}{dz}(r+h_z/2) + 
 h_x h_y \azmh \frac{du}{dz}(r-h_z/2) & = & h_xh_yh_z \fc  \\
\\
 \frac{h_y h_z}{h_x} [\axph (u(r+h_x) - u(r))  + 
                      \axmh (u(r-h_x) - u(r))] & + & \\ 
 \frac{h_z h_x}{h_y} [\ayph (u(r+h_y) - u(r))  + 
                      \aymh (u(r-h_y) - u(r))] & + & \\ 
 \frac{h_x h_y}{h_z} [\azph (u(r+h_z) - u(r))  + 
                      \azmh (u(r-h_z) - u(r))] & = &  h_xh_yh_z \fc  \\
\\
 \alxp (\Uxp - \Uc)  + 
 \alyp (\Uyp - \Uc)  + 
 \alzp (\Uzp - \Uc) & + & \\ 
 \alxm (\Uxm - \Uc)  + 
 \alym (\Uym - \Uc)  + 
 \alzm (\Uzm - \Uc) & = &  F  \\
 \end{eqnarray*}

where

\[\alxm  \equiv  \frac{h_yh_z}{h_x} \axmh,
 \alym  \equiv  \frac{h_zh_x}{h_y} \aymh, 
 \alzm  \equiv  \frac{h_xh_y}{h_z} \azmh \]
 \[\alxp  \equiv  \frac{h_yh_z}{h_x} \axph, 
 \alyp  \equiv  \frac{h_zh_x}{h_y} \ayph,
 \alzp  \equiv  \frac{h_xh_y}{h_z} \azph \]
 \[F = h_xh_yh_z f(r). \]

If we assume $a(x)\equiv 1$ (Poisson equation), $h\equiv h_x = h_y =
h_z$, and if we scale $\nabla\cdot(\ac \nabla \uc) = f$ by multiplying
each side by $C_h \equiv 1/h$, then we have

\[ \Uxp + \Uyp + \Uzp - 6\Uc + \Uxm + \Uym + \Uzm = h^2 \fc \]

%-----------------------------------------------------------------------
\subsection{Discretization between grid patches} \label{ss:discret-amr}
%-----------------------------------------------------------------------

All inter-level discretizations involve zones along a patch boundary;
however, not all zones along a patch boundary are involved in
inter-level discretization.  Since we will be discussing zones along a
patch boundary, we define a zone to be a ``\textit{face-zone}'' if it
lies along the external boundary of its containing grid patch.


%-----------------------------------------------------------------------
\subsubsection{Face-zone categorization}
%-----------------------------------------------------------------------

Face zones are assigned to one of the five categories listed below.
Note that ``neighbor'' implies ``in the same refinement level'',
whereas ``adjacent'' does not.


\begin{minipage}{1in}
\epsfig{file=fig/neighbor-boundary.eps,width=1in}
\end{minipage} \
\begin{minipage}{5.8in}
 A \textbf{boundary face-zone} is adjacent to the domain boundary.  We
assume boundary face-zones are always in the coarsest grid level; and
if one face-zone along a grid face is a boundary face-zone, then all
face-zones in that face are boundary face-zones
\end{minipage}

\begin{minipage}{1in}
\epsfig{file=fig/neighbor-covered.eps,width=1in}
\end{minipage} \
\begin{minipage}{5.8in}
A \textbf{covered face-zone} is covered by face zones in a finer
level.  Each grid that contains a covered face-zone contains a child
grid that covers the zone.
\end{minipage}

\begin{minipage}{1in}
\epsfig{file=fig/neighbor-fine.eps,width=1in}
\end{minipage} \
\begin{minipage}{5.8in}
A \textbf{fine face-zone} is adjacent to zones in a child of a
neighbor of the containing patch's parent.  Each fine face-zone is not
covered, its containing grid has a neighboring grid adjacent to the
face-zone, and the paired face-zone in the neigboring grid is covered.
We assume that all adjacent zones must not span more than one level.
\end{minipage}


\begin{minipage}{1in}
\epsfig{file=fig/neighbor-neighbor.eps,width=1in}
\end{minipage} \
\begin{minipage}{5.8in}
A \textbf{neighbor face-zone} is adjacent to a zone in a neighboring
patch.  The neighboring patch and containing patch may not necessarily
have the same parent.  Each neighbor face-zone is not covered, the
containing grid has a neighboring grid adjacent to the face-zone, and
the paired face-zone in the neighboring grid is not covered.
\end{minipage}

\begin{minipage}{1in}
\epsfig{file=fig/neighbor-coarse.eps,width=1in}
\end{minipage} \
\begin{minipage}{5.8in}
A \textbf{coarse face-zone} is adjacent to a zone in the containing
patch's parent, or a zone in a neighbor of the containing patch's
parent.  Each coars face-zone is not covered, and the containing grid
does not have a neighboring grid adjacent to the face-zone.  We assume
that all adjacent zones must not be more than one level apart.
\end{minipage}


We use these characteristics to derive algorithms for categorizing
face-zones.  While we don't need to know all categories (only coarse,
fine, and boundary face-zones are used), some categories are easier to
determine if other categories are known.  In particular, our algorithm
for categorizing coarse face-zones is to categorize all other
face-zones, and all uncategorized face-zones are then categorized as
coarse.

\begin{center}
\begin{tabular}{l|cccc}
category & boundary & covered & adjacent grid & covered neighbor \\ \hline
boundary & true &  \\
covered  &        & true \\
fine     & false & false & true & true \\
neighbor & false & false  & true& false \\
coarse   & false & false  & false \\
\end{tabular}
\end{center}

Categorizing requires four phases:

\begin{itemize}
\item[1.] Categorize boundary face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{grid} in \code{level(0)} \\
\>\> \textbf{for} \code{face} in \code{grid} \\
\>\>\> \textbf{if} \code{face} along boundary \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{face} \\
\>\>\>\>\> \code{categorize (face-zone , BOUNDARY)}
\end{tabbing}
\item[2.] Categorize covered face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to next-coarsest) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \code{sub-face = intersection (grid.face , parent(grid).face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{parent(grid)}\\
\>\>\>\>\>     \code{categorize (face-zone , COVERED)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{adjacent(parent(grid))}\\
\>\>\>\>\>     \textbf{if} \code{face-zone not covered} \\
\>\>\>\>\>\> \code{categorize (face-zone , ADJACENT-COVERED)}
\end{tabbing}
\item[3.] Categorize fine and neighbor face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to coarse) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \textbf{for} \code{neighbor} of \code{grid} \\
\>\>\>\> \code{sub-face = intersection (grid.face , neighbor.face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{grid}\\
\>\>\>\>\> \textbf{if} \code{face-zone is adjacent-covered} \\
\>\>\>\>\>\> \code{categorize (face-zone , FINE)} \\
\>\>\>\>\> \textbf{else if} \code{face-zone is not covered} \\
\>\>\>\>\>\> \code{categorize (face-zone , NEIGHBOR)}
\end{tabbing}
\item[4.] Categorize coarse face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{face-zone} in \code{hierarchy} \\
\>\> \textbf{if} \code{face-zone} not categorizeed \\
\>\>\>        \code{categorize (face-zone , COARSE)}
\end{tabbing}
\end{itemize}


%-----------------------------------------------------------------------
\subsubsection{Face-zone discretization}
%-----------------------------------------------------------------------

By default, zone connections are defined using stencil connections defined
using \hypre\ stencil values, which we derive in \S\ref{ss:discret-unigrid}.
Below, we derive modifications for each category of face-zone.


\begin{minipage}{1.75in}
\mbox{Coarse-to-fine, constant interpolation, $r=2$} \\
\epsfig{file=fig/discret-coarse-4.eps,width=1.5in} % width 2in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sideXP}  \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sideXP| \axpH \frac{v - U_0}{\frac{3}{4}H_x} \\
& = & \frac{H_yH_z}{H_x} \axpH \frac{4}{3} (\frac{1}{4} \sum_{k=1}^4 u_k - U_0)   \\
\end{eqnarray*}
\end{minipage}


\begin{minipage}{1.75in}
\mbox{Coarse-to-fine, linear interpolation, $r=2$} \\
\epsfig{file=fig/discret-coarse-8.eps,width=1.875in} % width 2.5in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sideXP} \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sideXP| \axpH \frac{v - U_0}{H_x} \\
& = & \frac{H_yH_z}{H_x}  \axpH (\frac{1}{8} \sum_{k=1}^8 u_k - U_0)   \\
\end{eqnarray*}
\end{minipage}

\begin{minipage}{1.75in}
\mbox{Fine-to-coarse, constant interpolation, $r=2$} \\
\epsfig{file=fig/discret-fine-1.eps,width=1.3125in}  % width 1.75in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sidexp} \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sidexp| \axph \frac{V - u_0}{\frac{3}{2}h_x} \\
& = & \frac{h_yh_z}{h_x}  \axph \frac{2}{3} (U_1 - u_0)   \\
\end{eqnarray*}
\end{minipage}

\begin{minipage}{1.75in}
\mbox{Fine-to-coarse, linear interpolation, $r=2$} \\
\epsfig{file=fig/discret-fine-3.eps,width=1.6875in}   % width 2.25in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sidexp}  \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sidexp| \axph \frac{V - u_0}{\frac{3}{2}h_x} \\
& = & \frac{h_yh_z}{h_x}  \axph \frac{2}{3} (\frac{1}{2}U_1 + \frac{1}{4}U_2 + \frac{1}{4}U_3 - u_0)   \\
\end{eqnarray*}
\end{minipage}


\begin{minipage}{1.75in}
\mbox{Fine-to-coarse, bilinear interpolation, $r=2$} \\
\epsfig{file=fig/discret-fine-4.eps,width=1.6875in}   % width 2.25in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sidexp}  \!\!\! & \as \nabla \us\cdot \norm \, d\surfel \\
& \approx & |\sidexp| \axph \frac{V - u_0}{\frac{3}{2}h_x} \\
& = & \frac{h_yh_z}{h_x}  \axph \frac{2}{3} (\frac{9}{16} U_1 + \frac{3}{16} U_2 + \frac{3}{16} U_3 + \frac{1}{16}U_4 - u_0)   \\
\end{eqnarray*}
\end{minipage}


\begin{minipage}{1.75in}
\mbox{Fine-to-coarse, quadratic interpolation, $r=2$} \\
\epsfig{file=fig/discret-fine-6.eps,width=1.875in}    % width 2.50in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
 & \oint_{\sidexp} \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
 & \approx & |\sidexp| \axph \frac{V - u_0}{\frac{3}{2}h_x} \\
& = & \frac{h_yh_z}{h_x}  \axph \frac{2}{3} (\frac{30}{32} U_1 + \frac{3}{32} U_2 + \frac{3}{32} U_3 + \frac{2}{32}U_4 - \frac{3}{32}U_5 - \frac{3}{32}U_6 - u_0)   \\
\end{eqnarray*}
\end{minipage}

@@@@@@@@

\begin{minipage}{1.75in}
\mbox{Coarse-to-fine, linear interpolation, $r=4$} \\
\epsfig{file=fig/discret-coarse-8-r4.eps,width=1.5in} % width 2in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sideXP}  \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sideXP| \axpH \frac{v - U_0}{\frac{3}{4}H_x} \\
& = & \frac{H_yH_z}{H_x} \axpH \frac{4}{3} (\frac{1}{4} \sum_{k=1}^4 u_k - U_0)   \\
\end{eqnarray*}
\end{minipage}

\begin{minipage}{1.75in}
\mbox{Fine-to-coarse, constant interpolation, $r=4$} \\
\epsfig{file=fig/discret-fine-1-r4.eps,width=1.3125in}  % width 1.75in
\end{minipage} \ \ \ \ 
\begin{minipage}{4.00in}
\begin{eqnarray*}
& \oint_{\sidexp} \!\!\! & \as \nabla \us\cdot \norm \, d\surfel  \\
& \approx & |\sidexp| \axph \frac{V - u_0}{\frac{3}{2}h_x} \\
& = & \frac{h_yh_z}{h_x}  \axph \frac{2}{3} (U_1 - u_0)   \\
\end{eqnarray*}
\end{minipage}

@@@@@@@@

%-----------------------------------------------------------------------
\subsection{Discretization at the domain boundary} \label{ss:discret-boundary}
%-----------------------------------------------------------------------

%\begin{center}
%\begin{minipage}{1.25in}
%\epsfig{file=fig/stencil0.eps,width=1.25in} \\
%\centerline{Piecewise constant}
%\end{minipage} \ \ \ 
%\begin{minipage}{1.25in}
%\epsfig{file=fig/stencil1.eps,width=1.25in} \\
%\centerline{Piecewise linear}
%\end{minipage} \ \ \ 
%\begin{minipage}{1.25in}
%\epsfig{file=fig/stencil2.eps,width=1.25in} \\
%\centerline{Piecewise quadratic}
%\end{minipage}
%\end{center}


% \begin{center}
% \begin{minipage}{6.0in}
% \epsfig{file=fig/discret-step-1.eps,width=6.0in}
% \end{minipage}
% \end{center}

% Types of matrix elements for a given unknown:
% 
% \begin{tabular}{ll}
% \textcolor{green}{internal} & \code{HYPRE\_SStructStencilSetEntry()} \\
% \textcolor{green}{overlapped internal} & \code{HYPRE\_SStructStencil} \\
% \textcolor{red}{neighbor} & \code{HYPRE\_SStructGridSetNeighborBox()}\\
% \textcolor{blue}{boundary} & \code{HYPRE\_SStructGraphAddEntries()}\\
% \textcolor{magenta}{fine-coarse parent} & \code{HYPRE\_SStructGraphAddEntries()}\\
% \textcolor{cyan}{coarse-fine child} & \code{HYPRE\_SStructGraphAddEntries()}\\
% \textcolor{brown}{fine-coarse parent--neighbor} & \code{HYPRE\_SStructGraphAddEntries()}\\
% \textcolor{yellow}{coarse-fine neighbor--child} & \code{HYPRE\_SStructGraphAddEntries()}\\
% \end{tabular}


%=======================================================================
\section{Porting to \enzo}
%=======================================================================

%=======================================================================
\section{Test Results} \label{s:results}
%=======================================================================

Tests are designed to evaluate the discretization accuracy, solver
performance, solver scaling, and solver robustness.  Below we define
notation that we will be used:

\begin{tabbing}
xxxxx\=xxxxx\=\kill
\> $N_0$ \> Root-grid zones per processor \\
\> $n_0$ \> Root-grid zones-per-axis  per processor \\
\> $N_P$ \> Number of processors \\
\> $N_G$ \> Number of grids \\
\> $N_L$ \> Number of levels \\
\> $N_Z$ \> Number of zones
\end{tabbing}

We include both serial and parallel problems, and unigrid and AMR problems with
the following range of sizes:

\begin{tabular}{l|ccccc} \\
Problem & $N_0$ & $N_P$ & $N_G$ & $N_L$ & $N_Z$ \\ \hline
serial-unigrid       & $8^3\ldots 128^3$ & & & \\
parallel-unigrid     & $16^3\ldots 128^3$ & & & \\
Simple serial AMR    & $32^3\ldots 128^3$ & & & \\
Simple parallel AMR  & $32^3\ldots 128^3$ & & & \\
General serial AMR   & $32^3\ldots 128^3$ & & & \\
General parallel AMR & $32^3\ldots 128^3$ & & & \\
Large AMR            & $32^3\ldots 128^3$ & & & \\
\end{tabular}

The following plots will be generated:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxx\=\kill
\>  \code{procs-mem} \> Processor count versus memory (bytes) \\
\>\code{procs-mem-zone} \> Processor count versus memory per zone (bytes) \\
\>\code{procs-time} \> Processor count versus time (seconds) \\
\>\code{procs-time-zone} \> Processor count versus time per zone (seconds) \\
\>\code{size-mem-zone} \>  Problem size (number of zones) versus memory per zone (bytes) \\
\>\code{size-mem-zone} \>  Problem size ($n$) versus memory (bytes) \\
\>\code{size-time-zone} \>  Problem size (number of zones) versus time per zone (seconds) \\
\>\code{size-time-zone} \>  Problem size ($n$) versus time (seconds)
\end{tabbing}

\EndDOCUMENT

\end{document}
%==================================================================

