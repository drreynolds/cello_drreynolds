%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890

\documentclass[10pt]{article}

\include{include}

%==================================================================
% Margins and spacing
%==================================================================

\begin{document}

%=======================================================================
\TITLE{\hypre\ SAMR Linear Solver}
      {James Bordner}
      {in preparation}
%=======================================================================

\tableofcontents
%======================================================================
\section{Overview}
%======================================================================

   \hypresolve\ will be used as a testbed for experimenting with the
   parallel solution of linear systems arising from self-gravity and
   radiation transfer algorithms defined on distributed SAMR
   hierarchies.  The purpose of this document is to specify the
   requirements, describe the design and implementation, and present
   test results for \hypresolve.

   We break the problem into two components: problem generation
   (\code{hypre-init}), and problem solution (\code{hypre-solve}).
   \code{hypre-init} takes as input parameters describing the problem
   characteristics in general terms, such as bounds on grid sizes,
   number of processors, description of how to distribute point
   masses, etc.  The output is a file of parameters that specify the
   exact problem to solve, including grid locations, sizes, levels,
   point mass locations, etc.  The file output by \code{hypre-init}
   can be subsequently input by \code{hypre-solve}.
   \code{hypre-solve} calls \hypre\ to assemble and solve a
   distributed linear system, and the solution, performance
   information, solver efficiency information, etc., are output.

%======================================================================
\section{Roadmap and Milestones}
%======================================================================


\begin{description}
\item[Driver: ] \code{hypre-solve} (H), \enzo\ (E)
\item[Equation: ] Poisson (P), diffusion equation (D)
\item[Datastructure: ] Unigrid (U), AMR (A)
\item[AMR refinement: ] $R=2$ (2), $R=2^k$ (2k), arbitrary $R$ (*)
\item[AMR discretization: ] piecewise constant (C), linear (L), quadratic (Q)
\end{description}

\begin{tabular}{cl|cc|cc|cc|ccc|ccc}
Done & \multicolumn{1}{c}{Description} & H&E & P&D & U&A & 2&[2k]&[*] & C&[L]&[Q] \\ \hline
\done & Unigrid Poisson equation & \done&\todo & \done&\todo & \done&\todo & \done&\todo&\todo & \done&\todo&\todo \\
\todo &AMR Poisson equation  & \done&\todo & \done&\todo & \todo&\done & \done&\todo&\todo & \done&\todo&\todo \\ \hline
\todo &Unigrid Diffusion equation& \done&\todo & \todo&\done& \done&\todo & \done&\todo&\todo & \done&\todo&\todo  \\
\todo  &AMR Diffusion equation& \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \done&\todo&\todo \\  \hline
\todo  &piecewise linear Poisson & \done&\todo & \done&\todo & \todo&\done & \done&\todo&\todo & \todo&\done&\todo \\
\todo  &  piecewise linear Diffusion & \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \todo&\done&\todo \\  
\todo &piecewise quadratic Poisson & \done&\todo & \done&\todo& \todo&\done & \done&\todo&\todo & \todo&\todo&\done \\  
\todo &piecewise quadratic Diffusion & \done&\todo & \todo&\done& \todo&\done & \done&\todo&\todo & \todo&\todo&\done \\  \hline
\todo &$2^k$ refinement factors  & \done&\todo & \todo&\done& \todo&\done & \todo&\done&\todo & \done&\todo&\todo\\
\todo & arbitrary refinement factors & \done&\todo & \todo&\done& \todo&\done & \todo&\todo&\done & \done&\todo&\todo \\  \hline
\todo &port to \enzo & \todo&\done & \fade&\fade& \fade&\fade & \fade&\fade&\fade & \fade&\fade&\fade
\end{tabular}

%======================================================================
\section{Components}
%======================================================================

%-----------------------------------------------------------------------
\subsection{\code{hypre-init}} \label{ss:hypre-init}
%-----------------------------------------------------------------------

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \todo\ \code{dimension} \> \code{\textit{int dimension}} \\
\> \todo\ \code{particle\_position\_clumpiness}  \\
\> \todo\ \code{particle\_mass\_clumpiness} \\
\> \todo\ \code{particle\_mass\_average} \\
\> \todo\ \code{sphere} \> \code{\textit{Scalar mass}, \textit{Scalar radius}, \textit{Scalar*3 center}} \\
\> \todo\  \code{domain\_extents} \\
\> \todo\  \code{processor\_grid} \\
\> \todo\ \code{discret} \> \code{\textit{int type}} \\
\> \todo\  \code{levels} \\
\> \todo\ \code{solver} \> \code{\{"fac"\} method}
\end{tabbing}



%-----------------------------------------------------------------------
\subsection{\code{hypre-solve}}  \label{ss:hypre-solve}
%-----------------------------------------------------------------------

The following table lists the input parameters to \code{hypre-solve}.

\begin{tabbing}
xxxxx\=xxxxxxxxxxx\=\kill
\> \done\ \code{dimension} \> \code{int} \icode{dimension} \\
\> \todo\ \code{domain} \> \code{Scalar*3} \icode{vertex-lower} \\
\> \> \code{Scalar*3} \icode{vertex-upper} \\
\> \done\ \code{sphere} \> \code{Scalar} \icode{mass} \\
\> \> \code{Scalar} \icode{radius} \\
\> \> \code{Scalar*3} \icode{center} \\
\> \done\ \code{point} \> \code{Scalar} \icode{mass} \\
\> \> \code{Scalar*3} \icode{location} \\
\> \done\ \code{grid} \> \code{int} \icode{id} \\
\> \> \code{int} \icode{parent-id} \\
\> \> \code{int} \icode{processor} \\
\> \> \code{Scalar} \icode{vertex-lower} \\
\> \> \code{Scalar} \icode{vertex-upper} \\
\> \> \code{int*3} \icode{index-lower} \\
\> \> \code{int*3} \icode{zone-count} \\
\> \todo\ \code{discret} \> \code{\icode{int} \icode{type}} \\
\> \todo\ \code{solver} \> \code{\{"fac"\}} \icode{method}
\end{tabbing}


The output of \code{hypre-solve} is a file containing the following:

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxx\=\kill
\> \todo\ \code{flops-balance} \>    \textit{Load balance efficiency with respect to flops}\\
\> \todo\ \code{flops-proc-avg} \> \textit{Average flop counts over processors} \\
\> \todo\ \code{flops-proc-max} \> \textit{Maximum flop counts over processors} \\
\> \todo\ \code{flops-total} \> \textit{Number of floating point operations} \\
\> \todo\ \code{mem-balance} \>    \textit{Load balance efficiency with respect to memory}\\
\> \todo\ \code{mem-proc-avg} \> \textit{Average memory usage over processors} \\
\> \todo\ \code{mem-proc-max} \>    \textit{Maximum memory usage over processors} \\
\> \todo\ \code{mem-total} \> \textit{Amount of memory used} \\
\> \todo\ \code{procs-total} \> \textit{Number of processors} \\
\> \todo\ \code{time-total} \>  \textit{Time to solution}
\end{tabbing}


%======================================================================
\section{\code{hypre-solve} Design} \label{s:design}
%======================================================================

%-----------------------------------------------------------------------
\subsection{Top-level design} \label{ss:design}
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
\subsubsection{\code{hypre-solve.cpp}}

%-----------------------------------------------------------------------
\subsubsection{\code{hypre.cpp}}

%-----------------------------------------------------------------------
\subsection{Classes} \label{ss:classes}
%-----------------------------------------------------------------------


%-----------------------------------------------------------------------
\subsubsection{AMR classes}


%\begin{center}
%\epsfig{file=uml/hierarchy.1,width=0.75in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-hierarchy.1,width=1.5in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-level.1,width=1.5in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/grid.1,     width=2.00in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-grid.1,width=2.5in}
%\end{center}

%-----------------------------------------------------------------------
\subsubsection{Problem classes}

\code{Problem}, \code{Sphere}, and \code{Point}

%\begin{center}
%\epsfig{file=uml/class-problem.1,width=2.0in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-sphere.1,width=1.0in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-point.1,width=1.0in}
%\end{center}

%-----------------------------------------------------------------------
\subsubsection{Discretization classes}


%\begin{center}
%\epsfig{file=uml/class-discret.1,width=2.5in}
%\end{center}
%\begin{center}
%\epsfig{file=uml/class-hypre.1,width=2.0in}
%\end{center}

%-----------------------------------------------------------------------
\subsection{\hypre\ interface}
%-----------------------------------------------------------------------

This section describes the sequence of calls in \hypre\ used for
setting up a linear system on an AMR hierarchy, and then solving it.

\begin{enumerate}
\item Initialize \hypre\ grids (\S\ref{sss:hypre-grids}) (\code{Hypre::init\_hierarchy()})
\item Initialize \hypre\ stencil (\S\ref{sss:hypre-stencil}) (\code{Hypre::init\_stencil()})
\item Initialize \hypre\ graph (\S\ref{sss:hypre-graph}) (\code{Hypre::init\_graph()})
\item Initialize \hypre\ matrix (\S\ref{sss:hypre-matrix}) (\code{Hypre::init\_matrix()})
\item Initialize \hypre\ vectors (\S\ref{sss:hypre-vectors}) (\code{Hypre::init\_rhs()})
\item Initialize \hypre\ solvers (\S\ref{sss:hypre-solvers}) (\code{Hypre::init\_solver()})
\item Apply \hypre\ solver (\code{Hypre::solve()})
\end{enumerate}

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ grids} \label{sss:hypre-grids}
%-----------------------------------------------------------------------

For each grid patch it owns, each processor creates a \hypre\ grid
object defining the grid's extents and variables.  

\begin{itemize}
\item \code{HYPRE\_SStructGridCreate()}
\item \code{HYPRE\_SStructGridSetExtents()}
\item \code{HYPRE\_SStructGridSetVariables()}
\item \code{HYPRE\_SStructGridAssemble()}
\end{itemize}

Neighboring grids do not need to be set using \hypre's
\code{HYPRE\_SStructGridSetNeighborBox()} function, since grids within an AMR
level are in the same \hypre\ ``part''.  However, since \hypresolve\
needs to know which zones in a grid are adjacent to neighboring grid
zones for setting up the inter-level grid elements, \hypresolve\ has
its own version of \code{HYPRE\_SStructGridSetNeighborBox()}.

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ stencil} \label{sss:hypre-stencil}
%-----------------------------------------------------------------------

  Create the stencil object which defines the matrix nonzeros within each grid.

\begin{itemize}
\item \code{HYPRE\_SStructStencilCreate()}
\item \code{HYPRE\_SStructStencilSetEntry()}
\end{itemize}

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ graph} \label{sss:hypre-graph}
%-----------------------------------------------------------------------

 Each processor creates a graph containing the nonzero structure of
 the matrix.

\begin{itemize}
\item \code{HYPRE\_SStructGraphCreate()}
\item \code{HYPRE\_SStructGraphSetStencil()}
\item \code{HYPRE\_SStructGraphAddEntries()}
\item \code{HYPRE\_SStructGraphAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ matrix} \label{sss:hypre-matrix}
%-----------------------------------------------------------------------

\begin{itemize}
\item \code{HYPRE\_SStructMatrixCreate()}
\item \code{HYPRE\_SStructMatrixInitialize()}
\item \code{HYPRE\_SStructMatrixSetBoxValues()}
\item \code{HYPRE\_SStructMatrixSetValues()}
\item \code{HYPRE\_SStructMatrixAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ vectors} \label{sss:hypre-vectors}
%-----------------------------------------------------------------------

\begin{itemize}
\item \code{HYPRE\_SStructVectorCreate()}
\item \code{HYPRE\_SStructVectorInitialize()}
\item \code{HYPRE\_SStructVectorSetBoxValues()}
\item \code{HYPRE\_SStructVectorAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsubsection{Initialize \hypre\ solvers} \label{sss:hypre-solvers}
%-----------------------------------------------------------------------

%=======================================================================
\subsection{Problem discretization} \label{ss:discretization}
%=======================================================================

\newcommand{\indvar}{r}
 \newcommand{\uc}{u(\indvar)}

 \newcommand{\uxp}{u(\indvar+h_x)}
 \newcommand{\uxm}{u(\indvar-h_x)}
 \newcommand{\uxph}{u(\indvar+\frac{h_x}{2})}
 \newcommand{\uxmh}{u(\indvar-\frac{h_x}{2})}

 \newcommand{\uyp}{u(\indvar+h_y)}
 \newcommand{\uym}{u(\indvar-h_y)}
 \newcommand{\uyph}{u(\indvar+\frac{h_y}{2})}
 \newcommand{\uymh}{u(\indvar-\frac{h_y}{2})}

 \newcommand{\uzp}{u(\indvar+h_z)}
 \newcommand{\uzm}{u(\indvar-h_z)}
 \newcommand{\uzph}{u(\indvar+\frac{h_z}{2})}
 \newcommand{\uzmh}{u(\indvar-\frac{h_z}{2})}

 \newcommand{\ac}{a(\indvar)}
 \newcommand{\axph}{a(\indvar+\frac{h_x}{2})}
 \newcommand{\axmh}{a(\indvar-\frac{h_x}{2})}
 \newcommand{\ayph}{a(\indvar+\frac{h_y}{2})}
 \newcommand{\aymh}{a(\indvar-\frac{h_y}{2})}
 \newcommand{\azph}{a(\indvar+\frac{h_z}{2})}
 \newcommand{\azmh}{a(\indvar-\frac{h_z}{2})}

 \newcommand{\alc}{\alpha_{0}}
 \newcommand{\alxp}{\alpha_{x}}
 \newcommand{\alxm}{\alpha_{\bar{x}}}
 \newcommand{\alyp}{\alpha_{y}}
 \newcommand{\alym}{\alpha_{\bar{y}}}
 \newcommand{\alzp}{\alpha_{z}}
 \newcommand{\alzm}{\alpha_{\bar{z}}}

 \newcommand{\Uc}{U_{0}}
 \newcommand{\Uxp}{U_{x}}
 \newcommand{\Uxm}{U_{\bar{x}}}
 \newcommand{\Uyp}{U_{y}}
 \newcommand{\Uym}{U_{\bar{y}}}
 \newcommand{\Uzp}{U_{z}}
 \newcommand{\Uzm}{U_{\bar{z}}}

We wish to discretize $- \nabla\cdot(\ac \nabla \uc) = \bar{\rho}$
on a structured AMR hierarchy with arbitrary refinement factor $r$
between successive levels.  We consider discretizing within levels in
\S\ref{sss:discret-unigrid}, and between
levels in \S\ref{sss:discret-amr}.

%-----------------------------------------------------------------------
\subsubsection{Unigrid Discretization} \label{sss:discret-unigrid}
%-----------------------------------------------------------------------

We wish to discretize $- \nabla\cdot(\ac \nabla \uc) = \bar{\rho}$
within a uniform $3$D grid level.  We assume that grid spacing
$h_{x}$, $h_{y}$, and $h_{z}$ within a level is uniform.  The unknowns
$u(r)$, (``$\Box$'' in the figure) are located at cell centers, and
the known coefficients $a(r)$ (``$\circ$'' in the figure) are
evaluated at cell faces.  The black unknown depends on grey unknowns
and grey coefficients.  To simplify visualization, the figure
represents the $2$D analog of the $3$D problem.  For the special case
of the Poisson equation, $a(r)\equiv 1$.

\begin{center}
\begin{minipage}{1.5in}
\epsfig{file=fig/stencil.eps,width=1.5in}
\end{minipage} 
\end{center}


 \begin{eqnarray*}
 \nabla\cdot(\ac \nabla \uc) & = & D_x (\ac D_x \uc) + D_y (\ac D_y \uc) + D_z (\ac D_z \uc) \\
 & \approx & \frac{\delta_{h_x}}{h_x} (\ac \frac{\delta_{h_x}}{h_x} \uc) + 
             \frac{\delta_{h_y}}{h_y} (\ac \frac{\delta_{h_y}}{h_y} \uc) + 
             \frac{\delta_{h_z}}{h_z} (\ac \frac{\delta_{h_z}}{h_z} \uc) \\
 & \approx & \alzm\Uzm +  \alym\Uym +  \alxm\Uxm 
  +  \alc\Uc 
  +  \alxp\Uxp +  \alyp\Uyp +  \alzp\Uzp,
 \end{eqnarray*}
where

\[\alxm  \equiv  \frac{1}{h_x^2} \axmh,
 \alym  \equiv  \frac{1}{h_y^2} \aymh, 
 \alzm  \equiv  \frac{1}{h_z^2} \azmh \]
 \[\alxp  \equiv  \frac{1}{h_x^2} \axph, 
 \alyp  \equiv  \frac{1}{h_y^2} \ayph,
 \alzp  \equiv  \frac{1}{h_z^2} \azph \]
 \[\alc   \equiv  - [\alxm + \alym + \alzm + \alxp + \alyp + \alzp]. \]

If we assume 1) $a(x)\equiv 1$, 2) $h\equiv h_x = h_y = h_z$, and 3)
we scale $\nabla\cdot(\ac \nabla \uc) = \bar{\rho}$ by multiplying
each side by $C_h \equiv (-h^2)$, then we have

\[\alxm  \equiv  -1,
 \alym  \equiv  -1,
 \alzm  \equiv  -1,
 \alxp  \equiv  -1,
 \alyp  \equiv  -1,
 \alzp  \equiv  -1,
 \alc   \equiv  6 \]

%-----------------------------------------------------------------------
\subsubsection{AMR Discretization} \label{sss:discret-amr}
%-----------------------------------------------------------------------

All inter-level discretizations involve zones along a patch boundary;
however, not all zones along a patch boundary are involved in
inter-level discretization.  Since we will be discussing zones along a
patch boundary, we define a zone to be a ``\textit{face-zone}'' if it
lies along the external boundary of its containing grid patch.

\begin{center}
\begin{minipage}{4in}
\epsfig{file=fig/neighbor.eps,width=4in}
\end{minipage}
\end{center}

\begin{description}
\item[boundary: ] The face-zone is adjacent to the domain boundary
\item[neighbor: ] The face-zone is adjacent to a zone in a neighboring patch.  The neighboring patch and containing patch may not necessarily have the same parent.
\item[coarse: ] The face-zone is adjacent to a zone in the containing patch's parent, or
a zone in a neighbor of the containing patch's parent.
\item[fine: ] The face-zone is adjacent to zones in a child of a neighbor of the containing patch's parent.
\item[covered: ] The face-zone is covered by face zones in a finer level.
\end{description}

By ``neighbor'' above, we imply ``in the same refinement level''.

Assumptions we make include the following:

\begin{itemize}
\item Adjacent zones must not span more than one level
\item Boundary face-zones are in the coarsest grid level
\item if one face-zone along a particular face is a boundary face-zone, then
all face-zones in that particular face are boundary face-zones
\end{itemize}

\subsubsection{categorization of face-zones}

Defining characteristics of face-zone categories include the following:

\begin{description}
\item [boundary: ] the face-zone is adjacent to the domain boundary
\item [covered: ] the grid containing the face-zone has a child grid that covers the zone
\item [fine: ] the face-zone is not covered, the containing grid has a neighboring grid adjacent to the face-zone, and the paired face-zone in the neigboring grid is covered
\item [neighbor: ] the face-zone is not covered, the containing grid has a neighboring grid adjacent to the face-zone, and the paired face-zone in the neighboring grid is not covered
\item [coarse: ] the face-zone is not covered, and the containing grid does not have a neighboring grid adjacent to the face-zone
\end{description}
\begin{tabular}{l|cccc}
category & boundary & covered & adjacent grid & covered neighbor \\ \hline
boundary & true &  \\
covered  &        & true \\
fine     & false & false & true & true \\
neighbor & false & false  & true& false \\
coarse   & false & false  & false \\
\end{tabular}

Categorizing requires four processes:

\begin{itemize}
\item[1.] Label boundary face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{grid} in \code{level-0} \\
\>\> \textbf{for} \code{face} in \code{grid} \\
\>\>\> \textbf{if} \code{face} along boundary \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{face} \\
\>\>\>\>\> \code{label (face-zone,boundary)}
\end{tabbing}
\item[2.] Label covered face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to coarse) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \code{sub-face = intersection(grid-face,parent(grid)-face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{parent(grid)}\\
\>\>\>\>\>     \code{label (face-zone,covered)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{adjacent(parent(grid))}\\
\>\>\>\>\>     \textbf{if} \code{face-zone not covered} \\
\>\>\>\>\>\> \code{label (face-zone,adjacent-covered)}
\end{tabbing}
\item[3-4.] Label fine and neighbor face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to coarse) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \code{sub-face = intersection(grid-face,parent(grid)-face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{parent(grid)}\\
\>\>\>\>\> \textbf{if} \code{face-zone is adjacent-covered} \\
\>\>\>\>\>\> \code{label (face-zone,fine)} \\
\>\>\>\>\> \textbf{else} \\
\>\>\>\>\>\> \code{label (face-zone,neighbor)} \\
\end{tabbing}
\item[5.] Label coarse face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{face-zone} in \code{hierarchy} \\
\>\> \textbf{if} \code{face-zone} not labeled \\
\>\>\>        \code{label (face-zone,coarse)}
\end{tabbing}
\end{itemize}

% \begin{tabbing}
% xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
% \> \textbf{for} \code{level} in \code{hierarchy} \textit{// (finest first)}\\
% \>\> \textbf{for} \code{grid} in \code{level} \\
% \\
% \>\>\> \textit{// *** Find boundary face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{face} in \code{grid} \\
% \>\>\>\>   \textbf{if} \code{face} is along \code{domain boundary} \\
% \>\>\>\>\>   \textbf{for} \code{face-zone} in \code{face} \\
% \>\>\>\>\>\>     \code{label (face-zone,boundary)} \\
% \\
% \>\>\> \textit{// *** Find covered face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{child} of \code{grid} \\
% \>\>\>\> \code{sub-face = intersection(child-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label (face-zone,covered)} \\
% \\
% \>\>\> \textit{// *** Find fine face-zones ***} \\
% \\
% \>\>\> \textit{// *** Find neighbor face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{neighbor} of \code{grid} \textit {// (include non-siblings)}\\
% \>\>\>\> \code{sub-face = intersection(neighbor-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label face-zone as boundary} \\
% \\
% \>\>\> \textit{// *** Find coarse face-zones ***} \\
% \end{tabbing}



% \begin{tabbing}
% xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
% \> \textbf{for} \code{level} in \code{hierarchy} \textit{// (finest first)}\\
% \>\> \textbf{for} \code{grid} in \code{level} \\
% \\
% \>\>\> \textit{// *** Find boundary face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{face} in \code{grid} \\
% \>\>\>\>   \textbf{if} \code{face} is along \code{domain boundary} \\
% \>\>\>\>\>   \textbf{for} \code{face-zone} in \code{face} \\
% \>\>\>\>\>\>     \code{label (face-zone,boundary)} \\
% \\
% \>\>\> \textit{// *** Find covered face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{child} of \code{grid} \\
% \>\>\>\> \code{sub-face = intersection(child-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label (face-zone,covered)} \\
% \\
% \>\>\> \textit{// *** Find fine face-zones ***} \\
% \\
% \>\>\> \textit{// *** Find neighbor face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{neighbor} of \code{grid} \textit {// (include non-siblings)}\\
% \>\>\>\> \code{sub-face = intersection(neighbor-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label face-zone as boundary} \\
% \\
% \>\>\> \textit{// *** Find coarse face-zones ***} \\
% \end{tabbing}

\subsubsection{discretization along face-zones}

By default, zone connections are defined using stencil connections defined
using \hypre\ stencil values, which we derive in \S\ref{sss:discret-unigrid}.
Below, we derive modifications for each category of face-zone.

\textbf{boundary face-zones}.

\textbf{covered face-zones}.


\textbf{fine face-zones}.

\textbf{neighbor face-zones}.  Neighbor face-zones are handled by \hypre\ stencil


\textbf{coarse face-zones}.



\begin{center}
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil0.eps,width=1.25in} \\
\centerline{Piecewise constant}
\end{minipage} \ \ \ 
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil1.eps,width=1.25in} \\
\centerline{Piecewise linear}
\end{minipage} \ \ \ 
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil2.eps,width=1.25in} \\
\centerline{Piecewise quadratic}
\end{minipage}
\end{center}



\begin{center}
\begin{minipage}{2in}
\epsfig{file=fig/discret6.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret5.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret4.eps,width=2.0in}
\end{minipage} \\
\begin{minipage}{4.5in}
\hfill $\Downarrow$
\end{minipage} \\
\begin{minipage}{2in}
\epsfig{file=fig/discret3.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret2.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret1.eps,width=2.0in}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{6.0in}
\epsfig{file=fig/discret-step-1.eps,width=6.0in}
\end{minipage}
\end{center}

Types of matrix elements for a given unknown:

\begin{tabular}{ll}
\textcolor{green}{internal} & \code{HYPRE\_SStructStencilSetEntry()} \\
\textcolor{green}{overlapped internal} & \code{HYPRE\_SStructStencil} \\
\textcolor{red}{neighbor} & \code{HYPRE\_SStructGridSetNeighborBox()}\\
\textcolor{blue}{boundary} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{magenta}{fine-coarse parent} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{cyan}{coarse-fine child} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{brown}{fine-coarse parent--neighbor} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{yellow}{coarse-fine neighbor--child} & \code{HYPRE\_SStructGraphAddEntries()}\\
\end{tabular}


%-----------------------------------------------------------------------
\subsection{Porting to \enzo}
%-----------------------------------------------------------------------

%=======================================================================
\section{Test Results} \label{s:results}
%=======================================================================

\begin{itemize}
\item Accuracy
\item Performance
\item Scaling
\item Robustness
\end{itemize}


\begin{tabular}{l|l} \\
\textbf{Term} & \textbf{Term description} \\ \hline
$N_0$ & Root-grid zones per processor \\
$n_0$ & Root-grid zones-per-axis  per processor \\
$N_P$ & Number of processors \\
$N_G$ & Number of grids \\
$N_L$ & Number of levels \\
$N_Z$ & Number of zones \\
\end{tabular}

\begin{tabular}{l|ccccc} \\
Problem & $N_0$ & $N_P$ & $N_G$ & $N_L$ & $N_Z$ \\ \hline
serial-unigrid       & $8^3:\sqrt{2}:128^3$ & & & \\
parallel-unigrid     & $16^3:2\ldots 128^3$ & & & \\
Simple serial AMR    & $32^3\ldots 128^3$ & & & \\
Simple parallel AMR  & $32^3\ldots 128^3$ & & & \\
General serial AMR   & $32^3\ldots 128^3$ & & & \\
General parallel AMR & $32^3\ldots 128^3$ & & & \\
Large AMR            & $32^3\ldots 128^3$ & & & \\
\end{tabular}

\begin{tabular}{l|l} \\
\textbf{Plot name} & \textbf{Plot description} \\ \hline
\code{procs-mem} & Processor count versus memory (bytes) \\
\code{procs-mem-zone} & Processor count versus memory per zone (bytes) \\
\code{procs-time} & Processor count versus time (seconds) \\
\code{procs-time-zone} & Processor count versus time per zone (seconds) \\
\code{size-mem-zone} &  Problem size (number of zones) versus memory per zone (bytes) \\
\code{size-mem-zone} &  Problem size ($n$) versus memory (bytes) \\
\code{size-time-zone} &  Problem size (number of zones) versus time per zone (seconds) \\
\code{size-time-zone} &  Problem size ($n$) versus time (seconds) \\
\end{tabular}

\EndDOCUMENT

\end{document}
%==================================================================

