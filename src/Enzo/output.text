Output of data, images, etc. requires several levels of parallelism.

Output is performed by every "process_write" processes.  For example,
if (process_write == 1), then every process writes, and if
(process_write == CkNumPes()), then only the root process writes.
However, "process_write" may be any integer in between 1 and
CkNumPes(), depending on the type of data being output.  For global
images, process_write is hard-coded to be CkNumPes().

The output proceedure begins by calling Simulation::p_output(),
which initiates looping through each output object in the Simulation.
Object migration is also turned off until the output procedure is
complete, to ensure each Block is processed exactly once per active
output object.

This looping is controlled by Simulation::output_first() and
Simulation::output_next().  output_first() sets the output counter
to the first output object; output_next() finds the next active
output object this cycle, and either initiates the output for that
object, or proceeds with the simulation if all output objects have
been processed.  If migration was turned off before the output
procedure, it is turned on before the simulation proceeds.

If Simulation::output_next() determines that a given output object
is scheduled to write this cycle, it calls Output::open() to open the
file(s), then Block::p_output() on each block owned by the
Simulation.

Block::p_output() accumulates the block data in the active
output object owned by the process Block's process.  This is done by
having each Block call the (non-entry) Output::block() function
on itself, which performs the actual data accumulation.  This may
involve reducing block data to a process-local image, or storing
information needed for subsequent output, e.g. the list of blocks
assigned to the process.  After each block calls Output::block()
on itself, it calls Main::p_output_reduce() to synchronize.

Main::p_output_reduce() ensures that all Blocks data within a process
have been accumulated before data between processes are accumulated
and written.  This reduction to the main chare may be overkill, since
inter-process reductions are only needed every "process_write"
processes, which may not require a global reduction.
Main::p_output_reduce() terminates the loop over all blocks, then
calls Simulation::p_output_reduce().

Simulation::p_output_reduce() calls the p_output_write() entry method
on the chare process group element that is assigned to perform the
actual write for data on this chare process group element.  After this
call, it then calls Simulation::output_next to continue the loop over
active output objects.  Note that output_next() is called by
non-writers in p_output_reduce(), but writers in p_output_write().

p_output_write() accumulates data between processes to be written.
Only writing processes should have this function called--if not it's
an error.  The process accumulates the data passed in the
p_output_write() argument list, and writes the data to disk.
p_output_write() is called "process_write" - 1 times--at the last
call, the processes's own data is written, the file is closed, and
Simulation::output_next() is called to continue the loop over active
output objects.  Note that output_next() is called by non-writers in
p_output_reduce(), but by writers in p_output_write().

========================================================================
OUTPUT FUNCTION LIST
========================================================================

 ( ) Simulation::p_output()

 ( ) Simulation::output_first()

 ( ) Simulation::output_next()

 ( ) Output::open()

 ( ) Block::p_output(index_output)

 ( ) Output::block(block)

 ( ) Main::p_output_reduce(count)

 ( ) Simulation::p_output_reduce()

 ( ) Simulation::p_output_write(process_data)

========================================================================
OUTPUT FUNCTION CODE
========================================================================

Simulation::p_output()

    [ save migration ]
    [ turn off migration ]

    output_first()
    output_next()

--------------------------------------------------

Simulation::output_first()
   index_output_ = 0;

--------------------------------------------------

Simulation::output_next()

   // find next output

   while (index_output_ < num_output && !output(index_output_).scheduled())
     ++index_output_;

   // apply next output, else proceed

   if (index_output_ < num_output)  
       output(index_output_).open()
       for (patch in simulation)
          for (block in patch)
               block.p_output()
   else 
       [ restore migration ]
       [ simulation proceed ]

--------------------------------------------------

Output::open()
   prepare process data
   if (ip % write_group_size == 0) {
       prepare writer data
       open file
   }

--------------------------------------------------

Block::p_output(index_output)

   output[index_output].block(this)
   main.p_output_reduce(NB)

--------------------------------------------------

Output::block(block)
   incorporate block data into process data

--------------------------------------------------

Main::p_output_reduce(count)
   ++counter >= count
      Simulation.p_output_reduce()

--------------------------------------------------

Simulation::p_output_reduce()
   if (not is_writer()) {
     p_output_write[writer()] (process data);
     output_next()
   } else {
     p_output_write[this](0)
   }

--------------------------------------------------

Simulation::p_output_write(process_data)
   assert is_writer()
   count_call ++;
   if (count_call == 1) {
      initialize write_data
   }
   if (process_data != 0) {
      write_data <-- process_data
   } else {
      write_data <-- this_data
   }

   if (count_call == write_group_size) {
      count_call = 0;
      write (write_data)
      close (write_data)
      output_next()
   }
   
========================================================================
