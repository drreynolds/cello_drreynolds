----------------------------------------------------------------------

Simulation::Simulation()

   initialize()
   run()

----------------------------------------------------------------------

Simulation::run()

   Block::p_initial()

----------------------------------------------------------------------

Block::p_initial()
   FieldBlock::allocate_array()
   FieldBlock::allocate_ghosts()
   FieldBlock::clear() [ should not be needed ]
   Initial::compute(this)
   initialize(cycle,time) [Enzo variables]
   prepare()

----------------------------------------------------------------------

{
|
|   Block::prepare()
|      Timestep::compute(this)
|      Stopping::complete()
|      Main::p_prepare(NB,cycle,time,dt,stop)
|
|   ----------------------------------------------------------------------
|
|   Main::p_prepare(count,cycle,time,dt,stop)
|      timestep reduce
|      stopping reduce
|      [every count]
|         output_open() [incomplete]
|         Simulation::p_refresh(cycle,time,dt,stop)
|         clear reduce
|
|   ----------------------------------------------------------------------
|
|   Simulation::p_refresh(cycle,time,dt,stop)
|      Monitor::print()
|      if (stop) 
|         Main::p_exit(NP)
|      } else {
|         Block::p_refresh()
|      }
|
|   ----------------------------------------------------------------------
|
|   Block::p_refresh()
|   
|      Boundary::enforce()
|      Block::p_refresh_face(length,array,axis_[xyz],face_[lower|upper]) 
|      Block::p_refresh_face(0,0,0,0);
|   
|   ----------------------------------------------------------------------
|   
|   Block::p_refresh_face(length,array,axis,face)
|      [ NF + 1 -> 1]
|      compute()
|   
|   ----------------------------------------------------------------------
|   
|   Block::compute()
|      Method::compute_block (this,time,dt)
|      prepare()
|
}

Main::p_exit(count)
{
 [count -> 1]
 CkExit()
}
======================================================================

Main::output_open()

   open file
   Simulation::p_output_open()
    
Simulation::p_output_open()

   open file [P==0]
   create empty images
   Block.p_output() [P's with Patch]

Block::p_output()

   contribute to output image
   Main::p_output_close(# blocks) 
     [ prefer Simulation::p_output_reduce(# local blocks) ]

Main::p_output_call_reduce()

   [ NB -> 1 ]
   [ overkill reduction--prefer Simulation ]
   Simulation::p_output_reduce()

Simulation::p_output_reduce()

   Main::p_output_reduce(Main)

Main::p_output_reduce

   Add incoming proc image to main image
   [ NP -> 1]
   write file
   close file
   output_next()

Main::output_next()

   increment output counter

======================================================================

                   Main  Simulation Block
----------------------------------------------------------------------
(*) m2s p_call()     M   >   S               call and continue
(*) s2b p_call()             S   >   B       call and continue
(*) b2m p_call(NB)   M   <       <   B       call and count to NB
(*) s2m p_call(NP)   M   <   S               call and count to NP
(?) b2s p_call(NLB)          S   <   B       (call and count to NLB)
(X) m2b              M   >       >   B        
